<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wq&#39;s blogs</title>
  
  <subtitle>王乾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wangqian.ltd/"/>
  <updated>2020-03-20T09:30:25.080Z</updated>
  <id>https://www.wangqian.ltd/</id>
  
  <author>
    <name>王乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>objc中向一个nil对象发送消息将会发生什么</title>
    <link href="https://www.wangqian.ltd/2020/03/20/oc-develop-objc-sendmsgnil/"/>
    <id>https://www.wangqian.ltd/2020/03/20/oc-develop-objc-sendmsgnil/</id>
    <published>2020-03-20T09:26:49.000Z</published>
    <updated>2020-03-20T09:30:25.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="objc中向一个nil对象发送消息将会发生什么"><a href="#objc中向一个nil对象发送消息将会发生什么" class="headerlink" title="objc中向一个nil对象发送消息将会发生什么"></a>objc中向一个nil对象发送消息将会发生什么</h3><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p><p>objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p><a id="more"></a><p>[obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;objc中向一个nil对象发送消息将会发生什么&quot;&gt;&lt;a href=&quot;#objc中向一个nil对象发送消息将会发生什么&quot; class=&quot;headerlink&quot; title=&quot;objc中向一个nil对象发送消息将会发生什么&quot;&gt;&lt;/a&gt;objc中向一个nil对象发送消息将会发生什么&lt;/h3&gt;&lt;p&gt;在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:&lt;/p&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;/p&gt;
&lt;p&gt;objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一个objc对象如何进行内存布局</title>
    <link href="https://www.wangqian.ltd/2020/03/19/oc-develop-objcmemory/"/>
    <id>https://www.wangqian.ltd/2020/03/19/oc-develop-objcmemory/</id>
    <published>2020-03-19T08:55:48.000Z</published>
    <updated>2020-03-19T09:32:15.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><p>所有的父类的成员变量和自己的成员变量都在该对象所对应的存储空间中。</p><p>每一个对象内部都有一个isa指针指向类对象，类对象存放本对象的以下内容</p><ol><li>对象方法列表</li><li>成员变量列表</li><li>属性列表</li><li>每个类对象内部也有一个isa指针指向元对象（meta class），元对象内部存放 类方法列表</li><li>superclass指针，指向对象的父类对象。<a id="more"></a></li></ol><p>根对象就是NSObject，它的superclass指针指向nil。</p><p>根元类的isa指针指向它自己，superclass指针指向NSObject。</p><img src="/2020/03/19/oc-develop-objcmemory/1.png"><h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向他的类对象,从而可以找到对象上的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个objc对象如何进行内存布局？（考虑有父类的情况）&quot;&gt;&lt;a href=&quot;#一个objc对象如何进行内存布局？（考虑有父类的情况）&quot; class=&quot;headerlink&quot; title=&quot;一个objc对象如何进行内存布局？（考虑有父类的情况）&quot;&gt;&lt;/a&gt;一个objc对象如何进行内存布局？（考虑有父类的情况）&lt;/h3&gt;&lt;p&gt;所有的父类的成员变量和自己的成员变量都在该对象所对应的存储空间中。&lt;/p&gt;
&lt;p&gt;每一个对象内部都有一个isa指针指向类对象，类对象存放本对象的以下内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象方法列表&lt;/li&gt;
&lt;li&gt;成员变量列表&lt;/li&gt;
&lt;li&gt;属性列表&lt;/li&gt;
&lt;li&gt;每个类对象内部也有一个isa指针指向元对象（meta class），元对象内部存放 类方法列表&lt;/li&gt;
&lt;li&gt;superclass指针，指向对象的父类对象。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>runtime消息转发机制</title>
    <link href="https://www.wangqian.ltd/2020/03/18/oc-develop-objc-msgForward/"/>
    <id>https://www.wangqian.ltd/2020/03/18/oc-develop-objc-msgForward/</id>
    <published>2020-03-18T06:53:42.000Z</published>
    <updated>2020-03-18T06:59:51.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么时候会报unrecognized-selector的异常？"><a href="#什么时候会报unrecognized-selector的异常？" class="headerlink" title="什么时候会报unrecognized selector的异常？"></a>什么时候会报unrecognized selector的异常？</h3><p>简单来说：</p><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。简单的流程如下，</p><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。<br>objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p><a id="more"></a><h4 id="1、Method-resolution"><a href="#1、Method-resolution" class="headerlink" title="1、Method resolution"></a>1、Method resolution</h4><p>objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p><h4 id="2、Fast-forwarding"><a href="#2、Fast-forwarding" class="headerlink" title="2、Fast forwarding"></a>2、Fast forwarding</h4><p>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p><h4 id="3、Normal-forwarding"><a href="#3、Normal-forwarding" class="headerlink" title="3、Normal forwarding"></a>3、Normal forwarding</h4><p>这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</p><p>为了能更清晰地理解这些方法的作用，请参demo：_objc_msgForward_demo</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么时候会报unrecognized-selector的异常？&quot;&gt;&lt;a href=&quot;#什么时候会报unrecognized-selector的异常？&quot; class=&quot;headerlink&quot; title=&quot;什么时候会报unrecognized selector的异常？&quot;&gt;&lt;/a&gt;什么时候会报unrecognized selector的异常？&lt;/h3&gt;&lt;p&gt;简单来说：&lt;/p&gt;
&lt;p&gt;当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。简单的流程如下，&lt;/p&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;br&gt;objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>synthesize和dynamic分别有什么作用？</title>
    <link href="https://www.wangqian.ltd/2020/03/05/synthesizeAnddynamic/"/>
    <id>https://www.wangqian.ltd/2020/03/05/synthesizeAnddynamic/</id>
    <published>2020-03-05T08:20:14.000Z</published>
    <updated>2020-03-11T06:57:32.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a>@synthesize和@dynamic分别有什么作用？</h3><ol><li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</li><li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法</li><li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃.</li><li>动态绑定:编译时没有问题，运行时才执行相应的方法。</li></ol><a id="more"></a><h3 id="在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p><ol><li>同时重写了 setter 和 getter 时</li><li>重写了只读属性的 getter 时</li><li>使用了 @dynamic 时</li><li>在 @protocol 中定义的所有属性</li><li>在 category 中定义的所有属性</li><li>重载的属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 实例变量 = 成员变量 ＝ ivar</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,readwrite,copy) NSString *firstName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController &#123;</span><br><span class="line">//    NSString *_firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//@synthesize firstName = _firstName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFirstName:(NSString *)firstName &#123;</span><br><span class="line">    _firstName  = [firstName copy];</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)firstName &#123;</span><br><span class="line">    return _firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p><ol><li>要么如第09行：手动创建 ivar</li><li>要么如第12行：使用@synthesize foo = _foo;关联 @property 与 ivar。</li></ol><h3 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p>1、对应基本数据类型默认关键字是 ：atomic,readwrite,assign<br>2、对于普通的 Objective-C对象是 ：atomic,readwrite,strong</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synthesize和-dynamic分别有什么作用？&quot;&gt;&lt;a href=&quot;#synthesize和-dynamic分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;@synthesize和@dynamic分别有什么作用？&quot;&gt;&lt;/a&gt;@synthesize和@dynamic分别有什么作用？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;&lt;/li&gt;
&lt;li&gt;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法&lt;/li&gt;
&lt;li&gt;@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃.&lt;/li&gt;
&lt;li&gt;动态绑定:编译时没有问题，运行时才执行相应的方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>property的本质</title>
    <link href="https://www.wangqian.ltd/2019/12/30/oc-develop-properyt/"/>
    <id>https://www.wangqian.ltd/2019/12/30/oc-develop-properyt/</id>
    <published>2019-12-30T07:14:49.000Z</published>
    <updated>2020-03-05T07:12:45.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="property-的本质是什么"><a href="#property-的本质是什么" class="headerlink" title="@property 的本质是什么"></a>@property 的本质是什么</h3><p>1、“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p><p>2、property在runtime中是objc_property_t定义：</p><p>typedef struct objc_property *objc_property_t;</p><a id="more"></a><h3 id="weak属性需要在dealloc中置nil么？"><a href="#weak属性需要在dealloc中置nil么？" class="headerlink" title="weak属性需要在dealloc中置nil么？"></a>weak属性需要在dealloc中置nil么？</h3><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理. </p><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p><h3 id="ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="ivar、getter、setter 是如何生成并添加到这个类中的?"></a>ivar、getter、setter 是如何生成并添加到这个类中的?</h3><p>“自动合成”( autosynthesis)</p><p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)</p><p>也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h3><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt; /*或者 #import &lt;objc/message.h&gt;*/</span><br><span class="line">static NSString *nameKey = @&quot;nameKey&quot;; //那么的key</span><br><span class="line"></span><br><span class="line">@interface NSObject ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Person)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> setter方法</span><br><span class="line"> */</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;nameKey, name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> getter方法</span><br><span class="line"> */</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;nameKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>分类并不会改变原有类的内存分布的情况，它是在运行期间决定的，此时内存的分布已经确定，若此时再添加实例会改变内存的分布情况，这对编译性语言是灾难，是不允许的。反观扩展(extension)，作用是为一个已知的类添加一些私有的信息，必须有这个类的源码，才能扩展，它是在编译器生效的，所以能直接为类添加属性或者实例变量。</p><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性。</p><h3 id="类扩展（Class-Extension）"><a href="#类扩展（Class-Extension）" class="headerlink" title="类扩展（Class Extension）"></a>类扩展（Class Extension）</h3><p>Extension是Category的一个特例。类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。</p><p>其实开发当中，我们几乎天天在使用。对于有些人来说像是最熟悉的陌生人。作用是：为一个类添加额外的原来没有变量，方法和属性。</p><pre><code>@interface XXX ()//私有属性//私有方法（如果不实现，编译时会报警,Method definition     for &apos;XXX&apos; not found）@end</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;property-的本质是什么&quot;&gt;&lt;a href=&quot;#property-的本质是什么&quot; class=&quot;headerlink&quot; title=&quot;@property 的本质是什么&quot;&gt;&lt;/a&gt;@property 的本质是什么&lt;/h3&gt;&lt;p&gt;1、“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。&lt;/p&gt;
&lt;p&gt;2、property在runtime中是objc_property_t定义：&lt;/p&gt;
&lt;p&gt;typedef struct objc_property *objc_property_t;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何让自己的类用 copy 修饰符？</title>
    <link href="https://www.wangqian.ltd/2019/12/16/oc-develop-nscopying/"/>
    <id>https://www.wangqian.ltd/2019/12/16/oc-develop-nscopying/</id>
    <published>2019-12-16T07:01:20.000Z</published>
    <updated>2019-12-16T07:11:44.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何让自己的类用-copy-修饰符？"><a href="#如何让自己的类用-copy-修饰符？" class="headerlink" title="如何让自己的类用 copy 修饰符？"></a>如何让自己的类用 copy 修饰符？</h3><pre><code> NSArray *tempArray = @[@&quot;1&quot;,@&quot;2&quot;];NSMutableArray *mutableCopyMuArray = [tempArray mutableCopy];// tempArray==0x600002649ce  mutableCopyMuArray==0x600002649ce0// 深copy tempArray 和 mutableCopyMuArray是完全不同的变量NSLog(@&quot;tempArray==%p,mutableCopyMuArray==%p&quot;,tempArray,mutableCopyMuArray); WQUser *user = [[WQUser alloc] initWithName:@&quot;lbj&quot; age:35];/* WQUser自己新建的类不具备copy功能，程序会crash 声明NSCopying并且实现协议方法后，新建的类会具备copy功能 user==0x600002f7b400,copyUser==0x600002f7b3e0，copy出来完全不同的变量 */WQUser *copyUser = [user copy];NSLog(@&quot;user==%p,copyUser==%p&quot;,user,copyUser);</code></pre><a id="more"></a><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p><p>具体步骤：</p><ol><li>需声明该类遵从 NSCopying 协议</li><li>实现 NSCopying 协议。该协议只有一个方法:</li></ol><pre><code>#import &quot;WQUser.h&quot;@interface WQUser ()&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readwrite, strong) NSMutableSet *friends;@end@implementation WQUser- (instancetype)initWithName:(NSString *)name                 age:(NSUInteger)age {if (self = [super init]) {_name = [name copy];_age = age;_friends = [[NSMutableSet alloc] init];}return self;}    #pragma mark - NSCopying- (id)copyWithZone:(nullable NSZone *)zone {WQUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age];copy.friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:true];return copy;}    @end    </code></pre><h3 id="如何重写带-copy-关键字的-setter？"><a href="#如何重写带-copy-关键字的-setter？" class="headerlink" title="如何重写带 copy 关键字的 setter？"></a>如何重写带 copy 关键字的 setter？</h3><pre><code>/* 不要在 setter 里进行像 if(_obj != newObj) 这样的判断 什么情况会在 copy setter 里做 if 判断？ 例如，车速可能就    有最高速的限制，车速也不可能出现负值，如果车子的最高速为    300，则 setter 的方法就要改写成这样：     - (void)setSpeed:(int)_speed{ if(_speed &lt; 0) speed = 0; if(_speed &gt; 300) speed = 300; _speed = speed; } */- (void)setName:(NSString *)name {//[_name release]; // MRC_name = [name copy];}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何让自己的类用-copy-修饰符？&quot;&gt;&lt;a href=&quot;#如何让自己的类用-copy-修饰符？&quot; class=&quot;headerlink&quot; title=&quot;如何让自己的类用 copy 修饰符？&quot;&gt;&lt;/a&gt;如何让自己的类用 copy 修饰符？&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; NSArray *tempArray = @[@&amp;quot;1&amp;quot;,@&amp;quot;2&amp;quot;];
NSMutableArray *mutableCopyMuArray = [tempArray mutableCopy];

// tempArray==0x600002649ce  mutableCopyMuArray==0x600002649ce0
// 深copy tempArray 和 mutableCopyMuArray是完全不同的变量
NSLog(@&amp;quot;tempArray==%p,mutableCopyMuArray==%p&amp;quot;,tempArray,mutableCopyMuArray);


 WQUser *user = [[WQUser alloc] initWithName:@&amp;quot;lbj&amp;quot; age:35];
/*
 WQUser自己新建的类不具备copy功能，程序会crash
 声明NSCopying并且实现协议方法后，新建的类会具备copy功能
 user==0x600002f7b400,copyUser==0x600002f7b3e0，copy出来完全不同的变量
 */

WQUser *copyUser = [user copy];

NSLog(@&amp;quot;user==%p,copyUser==%p&amp;quot;,user,copyUser);&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>关键字</title>
    <link href="https://www.wangqian.ltd/2019/12/10/oc-develop-keyword/"/>
    <id>https://www.wangqian.ltd/2019/12/10/oc-develop-keyword/</id>
    <published>2019-12-10T03:46:42.000Z</published>
    <updated>2019-12-10T04:32:13.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><p>什么情况使用 weak 关键字？</p><ol><li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li><li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak</li></ol><p>不同点：</p><ol><li>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</li><li>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象<a id="more"></a></li></ol><h3 id="使用-copy-关键字"><a href="#使用-copy-关键字" class="headerlink" title="使用 copy 关键字"></a>使用 copy 关键字</h3><p>用途:</p><ol><li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li><li>block 也经常使用 copy 关键字.</li></ol><p>解释：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p><h3 id="copy和mutableCopy区别和用法"><a href="#copy和mutableCopy区别和用法" class="headerlink" title="copy和mutableCopy区别和用法"></a>copy和mutableCopy区别和用法</h3><h4 id="浅拷贝（互相影响）"><a href="#浅拷贝（互相影响）" class="headerlink" title="浅拷贝（互相影响）"></a>浅拷贝（互相影响）</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的</p><h4 id="单层深拷贝"><a href="#单层深拷贝" class="headerlink" title="单层深拷贝"></a>单层深拷贝</h4><p>对于不可变的容器类对象(如NSArray、NSSet、NSDictionary)进 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化，属于单层深拷贝。<br>对于可变集合类对象(如NSMutableArray、NSMutableSet、NSMutableDictionary)，不管是进行 copy 操作还是 mutableCopy 操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p><h4 id="深拷贝（互不影响）"><a href="#深拷贝（互不影响）" class="headerlink" title="深拷贝（互不影响）"></a>深拷贝（互不影响）</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p><h4 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h4><p>非集合类对象的 copy 和 mutableCopy<br>我们对一个 NSString 属性进行 copy 和 mutableCopy –》对 NSString 进行 copy 操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行 mutableCopy 操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的 copy 操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。<br>NSMutableString 进行 copy 和 mutableCopy  –》对 NSMutableString 进行 copy 操作，其内存地址和指针地址都发生了变化，所以操作是深拷贝，和上面有所不同；进行 mutableCopy 操作，其内存地址和指针地址也都发生了变化，所以也是深拷贝。</p><p>总结：在非集合类对象中，对不可变对象进行 copy 操作，只仅仅是指针复制，进行 mutableCopy 操作，是内容复制。<br>对可变对象进行 copy 和 mutableCopy 操作，都是内容复制。</p><p>集合类对象的 copy 和 mutableCopy<br>对于不可变的集合类对象进行 copy 操作，只是改变了指针，其内存地址并没有发生变化；进行 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。（单层深拷贝）<br>对于可变集合类对象，不管是进行 copy 操作还是 mutableCopy 操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p><p>总结：</p><ol><li>NSMutableArray多次copy每次都会新建对象而NSArray多次copy只新建一次对象。5</li><li>对于容器而言，其元素对象始终是指针复制,归档的方法实现了真正的元素对象拷贝</li><li>容器内元素对象的唯一性。从数组中取出一个可变字符串，然后修改字符串对象，直接打印数组，数组中的这个字符串元素也会发生改变。</li><li>NSArray * array1 = @[@”1”,@”2”,@”3”];  NSArray * array2 = array1;  //  只是单纯的多一个指针指向</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么情况使用-weak-关键字，相比-assign-有什么不同？&quot;&gt;&lt;a href=&quot;#什么情况使用-weak-关键字，相比-assign-有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;什么情况使用 weak 关键字，相比 assign 有什么不同？&quot;&gt;&lt;/a&gt;什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/h3&gt;&lt;p&gt;什么情况使用 weak 关键字？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性&lt;/li&gt;
&lt;li&gt;自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。&lt;/li&gt;
&lt;li&gt;assign 可以用非 OC 对象,而 weak 必须用于 OC 对象&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Go语言常量和模拟枚举</title>
    <link href="https://www.wangqian.ltd/2019/11/22/GolangBasis-day06/"/>
    <id>https://www.wangqian.ltd/2019/11/22/GolangBasis-day06/</id>
    <published>2019-11-22T07:17:38.000Z</published>
    <updated>2019-11-22T07:35:56.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、常量和const关键字"><a href="#1、常量和const关键字" class="headerlink" title="1、常量和const关键字"></a>1、常量和const关键字</h3><p>特点：</p><ul><li>常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此。</li><li>const定义类型只有基本数据类型。string bool 数字（整型、浮点型、复数）</li><li>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</li></ul><a id="more"></a><p>变量三种命名方式：</p><pre><code>var num1 int = 3var num2 = 4num3 := 5</code></pre><p>常量定义格式：和变量的声明语法类似。</p><pre><code>显式类型定义： const b string = &quot;abc&quot;隐式类型定义： const b = &quot;abc&quot;    </code></pre><h3 id="2、iota-常量生成器（枚举类型）"><a href="#2、iota-常量生成器（枚举类型）" class="headerlink" title="2、iota 常量生成器（枚举类型）"></a>2、iota 常量生成器（枚举类型）</h3><pre><code>type Weekday intconst (Sunday Weekday = iotaMondayTuesdayWednesdayThursdayFridaySaturday)</code></pre><h3 id="2-1-将枚举值转换为字符串"><a href="#2-1-将枚举值转换为字符串" class="headerlink" title="2.1 将枚举值转换为字符串"></a>2.1 将枚举值转换为字符串</h3><p>当这个类型需要显示为字符串时，Go语言会自动寻找String()方法并进行调用。</p><h3 id="3、无类型常量"><a href="#3、无类型常量" class="headerlink" title="3、无类型常量"></a>3、无类型常量</h3><p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><pre><code>示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：    var x float32 = math.Pi    var y float64 = math.Pi    var z complex128 = math.Pi    如果 math.Pi 被确定为特定类型，比如 float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要一个明确的强制类型转换：    const Pi64 float64 = math.Pi    var x float32 = float32(Pi64) 强制类型转换方式语法和其他语言不同    var y float64 = Pi64    var z complex128 = complex128(Pi64)</code></pre><p>参考地址：<a href="http://c.biancheng.net/view/24.html" target="_blank" rel="noopener">http://c.biancheng.net/view/24.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、常量和const关键字&quot;&gt;&lt;a href=&quot;#1、常量和const关键字&quot; class=&quot;headerlink&quot; title=&quot;1、常量和const关键字&quot;&gt;&lt;/a&gt;1、常量和const关键字&lt;/h3&gt;&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此。&lt;/li&gt;
&lt;li&gt;const定义类型只有基本数据类型。string bool 数字（整型、浮点型、复数）&lt;/li&gt;
&lt;li&gt;常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mac下升级ruby环境版本</title>
    <link href="https://www.wangqian.ltd/2019/11/18/updateRuby/"/>
    <id>https://www.wangqian.ltd/2019/11/18/updateRuby/</id>
    <published>2019-11-18T09:57:07.000Z</published>
    <updated>2019-11-18T10:04:05.291Z</updated>
    
    <content type="html"><![CDATA[<p>在ios开发中会经常使用到cocoapods来管理第三方框架，在安装cocoapods的时候会涉及到ruby环境，有时候会因为版本过低会导致安装失败，本文主要讲一下如何升级ruby环境</p><a id="more"></a><p>安装rvm，rvm是可以让你拥有很多ruby版本的一个工具，具体的可以去了解一下（以下各个步骤均在terminal中实现） </p><pre><code>$ curl -L https://get.rvm.io | bash -s stable</code></pre><p>期间可能会问你sudo管理员密码，这里可能需要等待一段时间后就可以成功安装好 RVM</p><p>载入rvm环境</p><pre><code>$ source ~/.rvm/scripts/rvm</code></pre><p>检查是否安装成功，输入下面命令出现版本号等信息表示安装成功</p><pre><code>$ rvm -v</code></pre><p>用rvm安装ruby环境</p><pre><code>$ rvm install 2.2.4</code></pre><p>设置为默认版本</p><pre><code>$ rvm use 2.2.4 --default</code></pre><p>补充一些常用命令</p><p>rvm list 查看已安装ruby</p><p>rvm list known 列出ruby可安装版本信息</p><p>rvm remove 2.2.2 卸载一个已安装的ruby版本</p><p>gem source 查看已有源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ios开发中会经常使用到cocoapods来管理第三方框架，在安装cocoapods的时候会涉及到ruby环境，有时候会因为版本过低会导致安装失败，本文主要讲一下如何升级ruby环境&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/categories/GitHub/"/>
    
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Golang疑问</title>
    <link href="https://www.wangqian.ltd/2019/11/14/ColangQuestion/"/>
    <id>https://www.wangqian.ltd/2019/11/14/ColangQuestion/</id>
    <published>2019-11-14T09:47:43.000Z</published>
    <updated>2019-11-14T09:49:28.445Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、变量逃逸分析，不太明白变量是在栈、堆上？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、变量逃逸分析，不太明白变量是在栈、堆上？&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang语言指针</title>
    <link href="https://www.wangqian.ltd/2019/11/13/GolangBasis-day05/"/>
    <id>https://www.wangqian.ltd/2019/11/13/GolangBasis-day05/</id>
    <published>2019-11-13T09:33:37.000Z</published>
    <updated>2019-11-13T09:44:28.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>名词：指针类型、指针地址、&amp;、*</p><pre><code>//  ptr-pointer (既指针)得缩写var house string = &quot;777&quot;ptr := &amp;house // &amp;取地址操作符,对字符串取地址，将指针保存到变量ptr中fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)    // 指针类型为 *stringfmt.Printf(&quot;ptr address: %p\n&quot;, ptr) // 指针地址，指向对象在内存中存放的位置。每次运行都会发生变化。value := *ptr                         // *取值操作符，对指针进行取值操作fmt.Printf(&quot;value type: %T\n&quot;, value) // 打印为stringfmt.Printf(&quot;value address: %s\n&quot;, value)</code></pre><a id="more"></a><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><h3 id="使用指针变量获取命令行的输入信息"><a href="#使用指针变量获取命令行的输入信息" class="headerlink" title="使用指针变量获取命令行的输入信息"></a>使用指针变量获取命令行的输入信息</h3><pre><code>var mode = flag.String(&quot;mode&quot;, &quot;&quot;, &quot;process mode&quot;)flag.Parse()fmt.Println(*mode)go run src/day_02/Bool类型/bool.go --mode=7</code></pre><h3 id="创建指针的另一种方法-new-函数"><a href="#创建指针的另一种方法-new-函数" class="headerlink" title="创建指针的另一种方法 new()函数"></a>创建指针的另一种方法 new()函数</h3><pre><code>//用法如下：str2 := new(string)*str2 = &quot;加油加油&quot;fmt.Printf(&quot;%s\n&quot;, *str2) // 加油加油</code></pre><p>参考地址：<a href="http://c.biancheng.net/view/21.html" target="_blank" rel="noopener">http://c.biancheng.net/view/21.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;从指针获取指针指向的值&quot;&gt;&lt;a href=&quot;#从指针获取指针指向的值&quot; class=&quot;headerlink&quot; title=&quot;从指针获取指针指向的值&quot;&gt;&lt;/a&gt;从指针获取指针指向的值&lt;/h3&gt;&lt;p&gt;名词：指针类型、指针地址、&amp;amp;、*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//  ptr-pointer (既指针)得缩写

var house string = &amp;quot;777&amp;quot;

ptr := &amp;amp;house // &amp;amp;取地址操作符,对字符串取地址，将指针保存到变量ptr中

fmt.Printf(&amp;quot;ptr type: %T\n&amp;quot;, ptr)    // 指针类型为 *string
fmt.Printf(&amp;quot;ptr address: %p\n&amp;quot;, ptr) // 指针地址，指向对象在内存中存放的位置。每次运行都会发生变化。

value := *ptr                         // *取值操作符，对指针进行取值操作
fmt.Printf(&amp;quot;value type: %T\n&amp;quot;, value) // 打印为string
fmt.Printf(&amp;quot;value address: %s\n&amp;quot;, value)&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基本语法</title>
    <link href="https://www.wangqian.ltd/2019/09/19/GolangBasis-day04/"/>
    <id>https://www.wangqian.ltd/2019/09/19/GolangBasis-day04/</id>
    <published>2019-09-19T11:36:16.000Z</published>
    <updated>2019-10-14T10:10:39.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go语言类型的本质"><a href="#Go语言类型的本质" class="headerlink" title="Go语言类型的本质"></a>Go语言类型的本质</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>整型类型、浮点类型、字符串类型和布尔类型，对这些值进行增加或者删除的时候，会创建一个新值。当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>疑问点：<br>1、这些值进行增加或者删除的时候，会创建一个新值<br>2、引用类型、结构类型没看</p><a id="more"></a><h3 id="bool类型知识点"><a href="#bool类型知识点" class="headerlink" title="bool类型知识点"></a>bool类型知识点</h3><p>1、Go语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，否则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。</p><p>2、&amp;&amp; 的优先级比 || 高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）</p><p>3、布尔值并不会隐式转换为数字值 0 或 1，反之亦然。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>基本理解：字符串是字符的一个序列，字符是UTF-8编码格式。当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节。</p><h4 id="工具用法"><a href="#工具用法" class="headerlink" title="工具用法"></a>工具用法</h4><p>1、ASCII字符串长度使用len()函数。一个中文三个长度。</p><p>Unicode字符串长度使用utf8.RuneCountlnString()函数。</p><pre><code>var asciiStr string = &quot;abcd&quot;fmt.Println(len(asciiStr))fmt.Println(utf8.RuneCountInString(asciiStr))chineseStr := &quot;王乾&quot;fmt.Printf(&quot;%d\n&quot;, len(chineseStr))fmt.Println(utf8.RuneCountInString(chineseStr))输出结果：    wangqiandeMacBook-Pro:Golang_Study wangqian$ go run src/day_02/Bool类型/bool.go    4    4    6    2</code></pre><p>2、字符串检索</p><pre><code>strings.Index：正向搜索子字符串。strings.LastIndex：反向搜索子字符串。str1[0] 字符对应的ASCII编码表str1[0:] 以位置为0字符开始到结尾字符组成的字符串</code></pre><p>3、字符串遍历的两种方法</p><pre><code>ASCII 字符串遍历直接使用下标。Unicode字符串遍历用for rangeprintf(&quot;%c&quot;,a)；输出单个字符。printf(&quot;%d&quot;,a)；输出十进制整数。printf(&quot;%f&quot;,a)；输出十进制浮点数.printf(&quot;%s&quot;,a)；输出字符串。</code></pre><p>4、GO语言修改字符串</p><pre><code>Go语言中的字符串和其他高级语言（Java、C#）一样，默认是不可变的修改字符串时，可以将字符串转换为 []byte 进行修改。（是重新生成了一个字符串）</code></pre><p>5、字符串拼接方式</p><pre><code> 1、+拼接 2、使用字节缓冲拼接字符串 bytes.Buffer var stringBuffer bytes.Bufferstring1 := &quot;hhhh&quot;string2 := &quot;王乾&quot;stringBuffer.WriteString(string1)stringBuffer.WriteString(string2)fmt.Println(stringBuffer.String())</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Go语言类型的本质&quot;&gt;&lt;a href=&quot;#Go语言类型的本质&quot; class=&quot;headerlink&quot; title=&quot;Go语言类型的本质&quot;&gt;&lt;/a&gt;Go语言类型的本质&lt;/h3&gt;&lt;h4 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; title=&quot;内置类型&quot;&gt;&lt;/a&gt;内置类型&lt;/h4&gt;&lt;p&gt;整型类型、浮点类型、字符串类型和布尔类型，对这些值进行增加或者删除的时候，会创建一个新值。当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。&lt;/p&gt;
&lt;h4 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h4&gt;&lt;h4 id=&quot;结构类型&quot;&gt;&lt;a href=&quot;#结构类型&quot; class=&quot;headerlink&quot; title=&quot;结构类型&quot;&gt;&lt;/a&gt;结构类型&lt;/h4&gt;&lt;p&gt;疑问点：&lt;br&gt;1、这些值进行增加或者删除的时候，会创建一个新值&lt;br&gt;2、引用类型、结构类型没看&lt;/p&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo无法显示本地图片</title>
    <link href="https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/"/>
    <id>https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/</id>
    <published>2019-08-28T05:46:56.000Z</published>
    <updated>2019-08-28T06:18:27.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插件安装与配置"><a href="#1、插件安装与配置" class="headerlink" title="1、插件安装与配置"></a>1、插件安装与配置</h3><p>首先我们需要安装一个图片转化的插件，这个插件的名字叫 <font color="#000000">hexo-asset-image</font></p><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>但是这个插件的内容需要修改【不然可能会出Bug】<br>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre><code>&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data){  var config = hexo.config;  if(config.post_asset_folder){    var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)   var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;else   var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;link = link.substring(beginPos, endPos);var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;];for(var i = 0; i &lt; toprocess.length; i++){  var key = toprocess[i];  var $ = cheerio.load(data[key], {    ignoreWhitespace: false,    xmlMode: false,    lowerCaseTags: false,    decodeEntities: false  });  $(&apos;img&apos;).each(function(){    if ($(this).attr(&apos;src&apos;)){        // For windows style path, we replace &apos;\&apos; to &apos;/&apos;.        var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;);        if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;           !/^\s*\//.test(src)) {          // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed.          // In addition, to support multi-level local directory.          var linkArray = link.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos;;          });          var srcArray = src.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;;          });          if(srcArray.length &gt; 1)            srcArray.shift();          src = srcArray.join(&apos;/&apos;);          $(this).attr(&apos;src&apos;, config.root + link + src);          console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);        }    }else{        console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);        console.info&amp;&amp;console.info($(this));    }  });  data[key] = $.html();}  }});</code></pre><p>最后打开_config.yml文件，修改下述内容</p><pre><code>post_asset_folder: true</code></pre><h3 id="2、相对路径引用的标签插件"><a href="#2、相对路径引用的标签插件" class="headerlink" title="2、相对路径引用的标签插件"></a>2、相对路径引用的标签插件</h3><p>存档页和主页不能使用和文章内容中的常规语法来引用图片。<br>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><pre><code>{% asset_img example.jpg This is an example image %}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、插件安装与配置&quot;&gt;&lt;a href=&quot;#1、插件安装与配置&quot; class=&quot;headerlink&quot; title=&quot;1、插件安装与配置&quot;&gt;&lt;/a&gt;1、插件安装与配置&lt;/h3&gt;&lt;p&gt;首先我们需要安装一个图片转化的插件，这个插件的名字叫 &lt;font color=&quot;#0
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="HEXO" scheme="https://www.wangqian.ltd/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>iPhone和iPad分辨率</title>
    <link href="https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/"/>
    <id>https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/</id>
    <published>2019-08-22T08:02:28.000Z</published>
    <updated>2019-08-23T05:13:31.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iPhone和iPad分辨率"><a href="#iPhone和iPad分辨率" class="headerlink" title="iPhone和iPad分辨率"></a>iPhone和iPad分辨率</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/1.png" title="分辨率"><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPhone.png" title="iPhone"><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPad.png" title="iPad"><h3 id="iPad-Air"><a href="#iPad-Air" class="headerlink" title="iPad Air"></a>iPad Air</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadAir.png" title="iPad Air"><h3 id="iPad-Pro"><a href="#iPad-Pro" class="headerlink" title="iPad Pro"></a>iPad Pro</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadPro.png" title="iPad Pro"><h3 id="iPad-Mini"><a href="#iPad-Mini" class="headerlink" title="iPad Mini"></a>iPad Mini</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadMini.png" title="iPad Mini"><h3 id="iTouch"><a href="#iTouch" class="headerlink" title="iTouch"></a>iTouch</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iTouch.png" title="iTouch"><h3 id="判断设备类型"><a href="#判断设备类型" class="headerlink" title="判断设备类型"></a>判断设备类型</h3><p>#import &lt;sys/utsname.h&gt;</p><pre><code>+ (NSString *)deviceType{struct utsname systemInfo;uname(&amp;systemInfo);NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];//------------------------------iPhone---------------------------if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;if ([platform isEqualToString:@&quot;iPhone3,1&quot;] ||    [platform isEqualToString:@&quot;iPhone3,2&quot;] ||    [platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([platform isEqualToString:@&quot;iPhone5,1&quot;] ||    [platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;if ([platform isEqualToString:@&quot;iPhone5,3&quot;] ||    [platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;if ([platform isEqualToString:@&quot;iPhone6,1&quot;] ||    [platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;if ([platform isEqualToString:@&quot;iPhone9,1&quot;] ||    [platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7&quot;;if ([platform isEqualToString:@&quot;iPhone9,2&quot;] ||    [platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,1&quot;] ||    [platform isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;iPhone 8&quot;;if ([platform isEqualToString:@&quot;iPhone10,2&quot;] ||    [platform isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;iPhone 8 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,3&quot;] ||    [platform isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;iPhone X&quot;;if ([platform isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([platform isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([platform isEqualToString:@&quot;iPhone11,4&quot;] ||    [platform isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;//------------------------------iPad--------------------------if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([platform isEqualToString:@&quot;iPad2,1&quot;] ||    [platform isEqualToString:@&quot;iPad2,2&quot;] ||    [platform isEqualToString:@&quot;iPad2,3&quot;] ||    [platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([platform isEqualToString:@&quot;iPad3,1&quot;] ||    [platform isEqualToString:@&quot;iPad3,2&quot;] ||    [platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([platform isEqualToString:@&quot;iPad3,4&quot;] ||    [platform isEqualToString:@&quot;iPad3,5&quot;] ||    [platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;if ([platform isEqualToString:@&quot;iPad4,1&quot;] ||    [platform isEqualToString:@&quot;iPad4,2&quot;] ||    [platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;if ([platform isEqualToString:@&quot;iPad5,3&quot;] ||    [platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([platform isEqualToString:@&quot;iPad6,3&quot;] ||    [platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,7&quot;] ||    [platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,11&quot;] ||    [platform isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5&quot;;if ([platform isEqualToString:@&quot;iPad7,1&quot;] ||    [platform isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9-inch 2&quot;;if ([platform isEqualToString:@&quot;iPad7,3&quot;] ||    [platform isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5-inch&quot;;//------------------------------iPad Mini-----------------------if ([platform isEqualToString:@&quot;iPad2,5&quot;] ||    [platform isEqualToString:@&quot;iPad2,6&quot;] ||    [platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad mini&quot;;if ([platform isEqualToString:@&quot;iPad4,4&quot;] ||    [platform isEqualToString:@&quot;iPad4,5&quot;] ||    [platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad mini 2&quot;;if ([platform isEqualToString:@&quot;iPad4,7&quot;] ||    [platform isEqualToString:@&quot;iPad4,8&quot;] ||    [platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad mini 3&quot;;if ([platform isEqualToString:@&quot;iPad5,1&quot;] ||    [platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad mini 4&quot;;//------------------------------iTouch------------------------if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iTouch&quot;;if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iTouch2&quot;;if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iTouch3&quot;;if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iTouch4&quot;;if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iTouch5&quot;;if ([platform isEqualToString:@&quot;iPod7,1&quot;]) return @&quot;iTouch6&quot;;//------------------------------Samulitor-------------------------------------if ([platform isEqualToString:@&quot;i386&quot;] ||     [platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;return @&quot;Unknown&quot;;</code></pre><p>}</p><p>btw：所有设备型号官网地址： <a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Models</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iPhone和iPad分辨率&quot;&gt;&lt;a href=&quot;#iPhone和iPad分辨率&quot; class=&quot;headerlink&quot; title=&quot;iPhone和iPad分辨率&quot;&gt;&lt;/a&gt;iPhone和iPad分辨率&lt;/h3&gt;&lt;img src=&quot;/2019/08/22/oc-
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>GOROOT,GOPATH,GOBIN,project目录</title>
    <link href="https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/"/>
    <id>https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/</id>
    <published>2018-09-12T06:03:28.000Z</published>
    <updated>2019-09-12T06:50:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>我们接下来一个一个来看关于Go语言中的三个目录的详细解释<br>先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)</p><pre><code>wangqiandeMacBook-Pro:~ wangqian$ go envGOARCH=&quot;amd64&quot;GOBIN=&quot;/Users/wangqian/Desktop/Golang_Study/bin&quot;GOCACHE=&quot;/Users/wangqian/Library/Caches/go-build&quot;GOEXE=&quot;&quot;GOFLAGS=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;darwin&quot;GOOS=&quot;darwin&quot;GOPATH=&quot;/Users/wangqian/Desktop/Golang_Study&quot;GOPROXY=&quot;&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/local/go&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;clang&quot;CXX=&quot;clang++&quot;CGO_ENABLED=&quot;1&quot;GOMOD=&quot;&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/zm/zrfg_g0x7f970pp27h3whjd00000gn/T/go-build047476467=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</code></pre><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>其实就是golang 的安装路径<br>当你安装好golang之后其实这个就已经有了,Mac环境下默认为/usr/local/go</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>go命令依赖的一个重要环境变量：$GOPATH</p><p>其实可以把这个目录理解为工作目录，我个人定义的目录是：<br>GOPATH=”/Users/wangqian/Desktop/Golang_Study”<br>当然这个目录是需要添加到环境变量中的</p><p>其中Golang_Study文件下包括</p><pre><code>-- bin 箱子、容器，golang编译可执行文件存放路径-- src 标准要求代码（Standard Requirement Code）源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令-- pkg package包装 golang编译包时，生成的.a文件存放路径</code></pre><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p>首先先看一下我的目录结构</p><img src="/2018/09/12/GolangBasis-day02/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们接下来一个一个来看关于Go语言中的三个目录的详细解释&lt;br&gt;先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wangqiandeMacBook-Pro:~ wangqian$ go env
GOARCH=&amp;
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac下配置.bash_profile（环境变量）</title>
    <link href="https://www.wangqian.ltd/2018/09/10/Config-bash-profile/"/>
    <id>https://www.wangqian.ltd/2018/09/10/Config-bash-profile/</id>
    <published>2018-09-10T06:54:20.000Z</published>
    <updated>2019-09-12T07:01:27.411Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习Golang,在调试程序时报错，然后为了解决错误不小心改了.bash_profile这个文件，也就是配置环境变量，结果导致终端很多基本命令都不能使用，在网上找到一些解决办法，亲测有效。</p><p>1、在命令行中输入：</p><pre><code>export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</code></pre><p>这样可以保证命令行命令暂时可以使用。命令执行完之后先不要关闭终端。<br>如果你的命令行命令可以使用，请直接跳到第2步。</p><p>2、进入当前用户的home目录：</p><pre><code>cd ~/</code></pre><p>3、创建.bash_profile文件：</p><pre><code>touch .bash_profile</code></pre><p>4、 打开.bash_profile并编辑：</p><pre><code>open .bash_profile</code></pre><p>5、这样就打开了一个记事本，会显示你之前配置过的path，修改记事本，强烈建议先备份下，然后根据自己需要配置。</p><pre><code>JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATHexport GOPATH=/Users/wangqian/Desktop/Golang_Studyexport GOROOT=/usr/local/goexport GOBIN=$GOPATH/binexport PATH=$PATH:$GOBIN</code></pre><p>上面是我配置的Java环境和golang环境</p><p>6、command+s保存关闭文件</p><p>7、使修改后的配置生效命令：</p><pre><code>source .bash_profile</code></pre><p>8、验证环境变量是否配置成功</p><p>如果是java,在终端输入以下命令</p><pre><code>java -version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开始学习Golang,在调试程序时报错，然后为了解决错误不小心改了.bash_profile这个文件，也就是配置环境变量，结果导致终端很多基本命令都不能使用，在网上找到一些解决办法，亲测有效。&lt;/p&gt;
&lt;p&gt;1、在命令行中输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expor
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac环境下安装、配置golang</title>
    <link href="https://www.wangqian.ltd/2018/09/02/GolangBasis-day01/"/>
    <id>https://www.wangqian.ltd/2018/09/02/GolangBasis-day01/</id>
    <published>2018-09-02T03:20:42.000Z</published>
    <updated>2019-09-16T06:25:45.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h3><p>1、国内镜像下载地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a><br>2、终端中输入go ，若出现下图即安装成功。</p><pre><code>Go is a tool for managing Go source code.Usage:go &lt;command&gt; [arguments]The commands are:bug         start a bug reportbuild       compile packages and dependenciesclean       remove object files and cached filesdoc         show documentation for package or symbolenv         print Go environment informationfix         update packages to use new APIsfmt         gofmt (reformat) package sourcesgenerate    generate Go files by processing sourceget         download and install packages and dependenciesinstall     compile and install packages and dependencieslist        list packages or modulesmod         module maintenancerun         compile and run Go programtest        test packagestool        run specified go toolversion     print Go versionvet         report likely mistakes in packagesUse &quot;go help &lt;command&gt;&quot; for more information about a command.Additional help topics:buildmode   build modesc           calling between Go and Ccache       build and test cachingenvironment environment variablesfiletype    file typesgo.mod      the go.mod filegopath      GOPATH environment variablegopath-get  legacy GOPATH go getgoproxy     module proxy protocolimportpath  import path syntaxmodules     modules, module versions, and moremodule-get  module-aware go getpackages    package lists and patternstestflag    testing flagstestfunc    testing functionsUse &quot;go help &lt;topic&gt;&quot; for more information about that topic.</code></pre><p>3、开发环境构建：通过go version查看版本，在1.8版本前必须设置这个环境变量。1.8版本后（含1.8）如果没有设置使用默认值</p><pre><code>在 Unix 上默认为 $HOME/go 在 Windows 上默认为 %USERPROFILE%/go 在 Mac 上 GOPATH 可以通过修改 ~/.bash_profile 来设置</code></pre><h3 id="2、测试是否安装成功"><a href="#2、测试是否安装成功" class="headerlink" title="2、测试是否安装成功"></a>2、测试是否安装成功</h3><p>新建源码文件hello.go</p><pre><code>cd /Users/wangqian/Desktop/Golang_Study/src  //打开源文件存放的位置vim hello.go   // 编辑hello.go文件</code></pre><p>编码hello.go文件：</p><pre><code>package mainimport &quot;fmt&quot;func main(){fmt.Printf(&quot;hello world\n&quot;)}</code></pre><p>退出保存后直接运行</p><pre><code>go run hello.gowangqiandeMacBook-Pro:src wangqian$ go run hello.gohello world</code></pre><p>现在我们把源文件编译成二进制文件，并且运行当前二进制文件</p><pre><code>go build -ldflags &quot;-s -w&quot; -o hi.outwangqiandeMacBook-Pro:src wangqian$ go build -ldflags &quot;-s -w&quot; -o hi.outwangqiandeMacBook-Pro:src wangqian$ ./hi.outhello world</code></pre><p>这样在当前文件夹中就会存在一个源文件，一个编译文件<br>    <img src="/2018/09/02/GolangBasis-day01/1.png"></p><h3 id="3、go常用命令介绍"><a href="#3、go常用命令介绍" class="headerlink" title="3、go常用命令介绍"></a>3、go常用命令介绍</h3><p>go run 路径需要完整的路径到src<br>wangqiandeMacBook-Pro:Golang_Study wangqian$ go run src/day_01/hello_world.go</p><p>hello world</p><p>wangqiandeMacBook-Pro:Golang_Study wangqian$ go run day_01/hello_world.go</p><p>stat day_01/hello_world.go: no such file or directory</p><p>go build 编译的时候制定固定的包就行了，不需要带上src<br>go build day_01  go build 是在当前文件路径生成可执行文件，<br>go build -o bin/hello2 day_01  指定在bin路径下生成名称hello2的可执行文件</p><p>go install day_01  生成可执行文件在bin目录下<br>前提是go环境bin路径修改过 GOBIN=”/Users/wangqian/Desktop/Golang_Study/bin”</p><p>go fmt day_01  格式化代码  直接包名路径就行</p><p>在VSCode中目录结构如下图所示：</p><img src="/2018/09/02/GolangBasis-day01/2.png"><h3 id="4、设置GOPATH环境变量"><a href="#4、设置GOPATH环境变量" class="headerlink" title="4、设置GOPATH环境变量"></a>4、设置GOPATH环境变量</h3><p>开始写 go 项目代码之前，需要我们先配置好环境变量。编辑 ~/.bash_profile（在终端中运行 vi ~/.bash_profile 即可）来添加下面这行代码（如果你找不到 .bash_profile，那自己创建一个就可以了）</p><pre><code>export GOPATH=$HOME/go</code></pre><p>保存然后退出你的编辑器。然后在终端中运行下面命令</p><pre><code>source ~/.bash_profile</code></pre><p>提示：$HOME是每个电脑下的用户主目录，每个电脑可能不同，可以在终端运行 echo $HOME 获取<br>GOROOT 默认是在 /usr/local/go，如果没有，可以在 bash_profile 文件中设置。<br>export GOROOT=/usr/local/go<br>然后保存并退出编辑器，运行 source ~/.bash_profile 命令即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、下载&quot;&gt;&lt;a href=&quot;#1、下载&quot; class=&quot;headerlink&quot; title=&quot;1、下载&quot;&gt;&lt;/a&gt;1、下载&lt;/h3&gt;&lt;p&gt;1、国内镜像下载地址：&lt;a href=&quot;https://golang.google.cn/dl/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Desktop 链接 码云、GitLab使用方法</title>
    <link href="https://www.wangqian.ltd/2018/09/01/GitHub-Desktop/"/>
    <id>https://www.wangqian.ltd/2018/09/01/GitHub-Desktop/</id>
    <published>2018-09-01T07:18:05.000Z</published>
    <updated>2019-09-01T07:32:17.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、添加SSH私钥并连接"><a href="#1、添加SSH私钥并连接" class="headerlink" title="1、添加SSH私钥并连接"></a>1、添加SSH私钥并连接</h3><pre><code>1、ssh-add /Users/wangqian/id_rsa     /Users/wangqian/id_rsa 为私钥的地址2、ssh -T git@gitlab.ttsing.com当出现 Welcome to GitLab, wq! 表示连接成功</code></pre><h3 id="2、如何从码云、GitLab导入到GitHubDeskTop桌面工具"><a href="#2、如何从码云、GitLab导入到GitHubDeskTop桌面工具" class="headerlink" title="2、如何从码云、GitLab导入到GitHubDeskTop桌面工具"></a>2、如何从码云、GitLab导入到GitHubDeskTop桌面工具</h3><p>1、先用命令行切换到本地的目录。<br>2、使用git clone 码云GIT地址 命令将项目克隆到本地。<br>3、在GitHub Desktop上添加(Add)本地项目(local path)。<br>4、在GitHub Desktop上尽情地提交、同步吧！</p><h3 id="3、如何将本地的项目上传到码码云、GitLab"><a href="#3、如何将本地的项目上传到码码云、GitLab" class="headerlink" title="3、如何将本地的项目上传到码码云、GitLab"></a>3、如何将本地的项目上传到码码云、GitLab</h3><p>1、选择本地目录，在GitHub Desktop上添加本地项目。<br>2、在码云GIT上新建项目。<br>3、 命令行使用git remote add origin GIT地址 将本地项目与码云GIT项目建立关系。<br>4、先使用命令git pull origin master 同步代码。<br>5、使用命令git push origin master 将本地代码推送到远程项目。<br>6、在GitHub Desktop上尽情地提交、同步吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、添加SSH私钥并连接&quot;&gt;&lt;a href=&quot;#1、添加SSH私钥并连接&quot; class=&quot;headerlink&quot; title=&quot;1、添加SSH私钥并连接&quot;&gt;&lt;/a&gt;1、添加SSH私钥并连接&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、ssh-add /Users/wangq
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://www.wangqian.ltd/2018/08/29/MarkdownGrammar/"/>
    <id>https://www.wangqian.ltd/2018/08/29/MarkdownGrammar/</id>
    <published>2018-08-29T06:05:32.000Z</published>
    <updated>2019-08-29T09:26:10.651Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/1.png"><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h3><p>加粗 - 要加粗的文字左右分别用两个*号包起来</p><p>斜体 - 要倾斜的文字左右分别用一个*号包起来</p><p>斜体加粗 - 要倾斜和加粗的文字左右分别用三个*号包起来</p><p>删除线 - 要加删除线的文字左右分别用两个~~号包起来</p><p>修改字体颜色 - <font color="#FF0000"> 字体改成红色了 </font><br>示例：</p><pre><code>**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~&lt;font color=红色&gt; 字体改成红色了 &lt;/font&gt;</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/2.png"><h3 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h3><p>在需要引用的文字前加&gt;即可。<br>示例：</p><pre><code>&gt;这里是引用的内容&gt;&gt;这里是引用的内容</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/3.png" title="This is an image"><h3 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h3><p>三个或者三个以上 - 或者 * 都可以<br>示例：</p><pre><code>-------*******</code></pre><h3 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h3><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><h3 id="6、超链接"><a href="#6、超链接" class="headerlink" title="6、超链接"></a>6、超链接</h3><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[百度](http://baidu.com)</code></pre><p>效果如下：</p><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="7、表格"><a href="#7、表格" class="headerlink" title="7、表格"></a>7、表格</h3><p>语法如下：</p><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;h3 id=&quot;1、标题&quot;&gt;&lt;a href=&quot;#1、标题&quot; class=&quot;headerlink&quot; title=&quot;1、标题&quot;&gt;&lt;/a&gt;1、标题&lt;/h3&gt;&lt;p&gt;在想要设
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://www.wangqian.ltd/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>标识符、关键字、变量</title>
    <link href="https://www.wangqian.ltd/2018/08/16/GolangBasis-day03/"/>
    <id>https://www.wangqian.ltd/2018/08/16/GolangBasis-day03/</id>
    <published>2018-08-16T07:39:25.000Z</published>
    <updated>2019-09-23T03:49:19.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、标识符和关键字"><a href="#1、标识符和关键字" class="headerlink" title="1、标识符和关键字"></a>1、标识符和关键字</h3><p>标识符 ：Go语言的代码中的几乎所有东西都有一个名称或标识符<br>_本身就是一个特殊的标识符，被称为空白标识符.它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃</p><p>关键字：Go中25个关键字或保留字。（var、if之类）<br>和其它语言一样，关键字不能够作标识符使用。</p><p>预定义标识符：Go 语言还有 36 个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数（int32之类）</p><h3 id="2、变量的声明"><a href="#2、变量的声明" class="headerlink" title="2、变量的声明"></a>2、变量的声明</h3><p>Go语言是静态类型语言，在检查函数调用中编译器检查变量类型的正确性，因此变量必须有明确的类型。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。</p><p>当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。（实例变量存在堆中，默认初始化值）</p><p>数据类型：基本数据类型和引用数据类型</p><p>GO语言基本数据类型：</p><p>string</p><p>bool</p><p>int（32系统占4字节，64位系统占8字节）、int8（一个字节）、int16、int32 （rune）、int64  </p><p>uint（32系统占4字节，64位系统占8字节）、uint8（byte）、uint16、uint32、uint64、uintptr</p><p>float32、float64</p><p>complex64、complex128     complex复杂的</p><p>注意：<br>Golang在没声明具体整型时，默认为int;<br>Golang在没声明具体浮点型时，默认为float64</p><h4 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h4><p>声明变量的一般形式是使用 var 关键字：var identifier type </p><h4 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h4><pre><code>1    var (2        a int3        b string4        c []float325        d func() bool6        e struct {7            x int8        }9    )</code></pre><h4 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h4><pre><code>1    func main() {2       x:=1003       a,s:=1, &quot;abc&quot;4    }</code></pre><p>需要注意的是，简短模式（short variable declaration）有以下限制：</p><ul><li>只能用在函数内部</li><li>不能提供数据类型。</li><li>定义变量，同时显式初始化。</li></ul><p>匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符</p><p>特点：</p><p>1、可以像其他标识符那样用于变量的声明或赋值，但任何赋给这个标识符的值都将被抛弃</p><p>2、值不能在后续的代码中使用，也不可以使用这个这个标识符作为变量对其它变量的进行赋值或运算</p><p>3、匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、标识符和关键字&quot;&gt;&lt;a href=&quot;#1、标识符和关键字&quot; class=&quot;headerlink&quot; title=&quot;1、标识符和关键字&quot;&gt;&lt;/a&gt;1、标识符和关键字&lt;/h3&gt;&lt;p&gt;标识符 ：Go语言的代码中的几乎所有东西都有一个名称或标识符&lt;br&gt;_本身就是一个特
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>

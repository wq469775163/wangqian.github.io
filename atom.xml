<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wq&#39;s blogs</title>
  
  <subtitle>王乾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wangqian.ltd/"/>
  <updated>2020-04-13T08:49:24.699Z</updated>
  <id>https://www.wangqian.ltd/</id>
  
  <author>
    <name>王乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在block内如何修改block外部变量？</title>
    <link href="https://www.wangqian.ltd/2020/04/13/oc-develop-blockOutside/"/>
    <id>https://www.wangqian.ltd/2020/04/13/oc-develop-blockOutside/</id>
    <published>2020-04-13T08:36:59.000Z</published>
    <updated>2020-04-13T08:49:24.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在block内如何修改block外部变量？"><a href="#在block内如何修改block外部变量？" class="headerlink" title="在block内如何修改block外部变量？"></a>在block内如何修改block外部变量？</h3><p>1、Block中不允许修改外部变量的值。这里所说的外部变量的值，指的是栈中指针的内存地址。__block修饰之后，立马将“外部变量在栈中的内存地址放到堆中”，如果不做特殊修改就一直在堆中，进而做到在block内部修改外部变量。</p><p>2、大小比较：堆地址要小于栈地址。iOS中一个进程的栈区内存只有1M，Mac也只有8M。</p><p>3、这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址</p><pre><code>__block int a = 5;NSLog(@&quot;定义前：%p&quot;,&amp;a); // 1、栈中void (^foo)(void) = ^{    a = 6;    NSLog(@&quot;block内部：%p&quot;,&amp;a); //3、堆中};NSLog(@&quot;定义后：%p&quot;,&amp;a);//2、堆中foo();定义前：0x16fda86f8定义后：0x155b22fc8block内部： 0x155b22fc8NSMutableString *a = [NSMutableString stringWithString:@&quot;Tom&quot;];NSLog(@&quot;\n 定以前：------------------------------------\n\      a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);void (^foo)(void) = ^{    a.string = @&quot;Jerry&quot;;    NSLog(@&quot;\n block内部：------------------------------------\n\     a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);//        a = [NSMutableString stringWithString:@&quot;William&quot;];};foo();NSLog(@&quot;\n 定以后：------------------------------------\n\      a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);</code></pre><img src="/2020/04/13/oc-develop-blockOutside/1.png"><a id="more"></a><h3 id="使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？"><a href="#使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？" class="headerlink" title="使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？"></a>使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><p>1、统的某些block api中，UIView的block版本写动画时不需要考虑，所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p><pre><code>[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot;                                              object:nil                       queue:[NSOperationQueue mainQueue]                                         usingBlock:^(NSNotification * notification) {                                               self.someProperty = xyz; }]; </code></pre><p>这些情况不需要考虑“引用循环”。</p><p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p><pre><code>__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^{__typeof__(self) strongSelf = weakSelf;[strongSelf doSomething];[strongSelf doSomethingElse];} );     __weak __typeof__(self) weakSelf = self; _observer = [[NSNotificationCenter defaultCenter]     addObserverForName:@&quot;testKey&quot;                                                                   object:nil                                                                queue:nil                                                           usingBlock:^(NSNotification *note) { __typeof__(self) strongSelf = weakSelf; [strongSelf         dismissModalViewControllerAnimated:YES];</code></pre><p> }];</p><p> self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。</p><p>检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具 FBRetainCycleDetector 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在block内如何修改block外部变量？&quot;&gt;&lt;a href=&quot;#在block内如何修改block外部变量？&quot; class=&quot;headerlink&quot; title=&quot;在block内如何修改block外部变量？&quot;&gt;&lt;/a&gt;在block内如何修改block外部变量？&lt;/h3&gt;&lt;p&gt;1、Block中不允许修改外部变量的值。这里所说的外部变量的值，指的是栈中指针的内存地址。__block修饰之后，立马将“外部变量在栈中的内存地址放到堆中”，如果不做特殊修改就一直在堆中，进而做到在block内部修改外部变量。&lt;/p&gt;
&lt;p&gt;2、大小比较：堆地址要小于栈地址。iOS中一个进程的栈区内存只有1M，Mac也只有8M。&lt;/p&gt;
&lt;p&gt;3、这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__block int a = 5;
NSLog(@&amp;quot;定义前：%p&amp;quot;,&amp;amp;a); // 1、栈中
void (^foo)(void) = ^{
    a = 6;
    NSLog(@&amp;quot;block内部：%p&amp;quot;,&amp;amp;a); //3、堆中
};
NSLog(@&amp;quot;定义后：%p&amp;quot;,&amp;amp;a);//2、堆中
foo();

定义前：0x16fda86f8
定义后：0x155b22fc8
block内部： 0x155b22fc8


NSMutableString *a = [NSMutableString stringWithString:@&amp;quot;Tom&amp;quot;];
NSLog(@&amp;quot;\n 定以前：------------------------------------\n\
      a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&amp;quot;, a, &amp;amp;a);
void (^foo)(void) = ^{
    a.string = @&amp;quot;Jerry&amp;quot;;
    NSLog(@&amp;quot;\n block内部：------------------------------------\n\
     a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&amp;quot;, a, &amp;amp;a);
//        a = [NSMutableString stringWithString:@&amp;quot;William&amp;quot;];
};
foo();
NSLog(@&amp;quot;\n 定以后：------------------------------------\n\
      a指向的堆中内存对象的地址：%p；a在栈中的指针地址：%p&amp;quot;, a, &amp;amp;a);&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;/2020/04/13/oc-develop-blockOutside/1.png&quot;&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>autoreleasepool</title>
    <link href="https://www.wangqian.ltd/2020/04/08/autoreleasepool/"/>
    <id>https://www.wangqian.ltd/2020/04/08/autoreleasepool/</id>
    <published>2020-04-08T06:29:17.000Z</published>
    <updated>2020-04-08T06:35:36.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="objc使用什么机制管理对象内存？"><a href="#objc使用什么机制管理对象内存？" class="headerlink" title="objc使用什么机制管理对象内存？"></a>objc使用什么机制管理对象内存？</h3><p>通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p><h3 id="ARC通过什么方式帮助开发者管理内存？"><a href="#ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="ARC通过什么方式帮助开发者管理内存？"></a>ARC通过什么方式帮助开发者管理内存？</h3><p>ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。<br> 在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。</p><a id="more"></a><h3 id="一个autorealese对象在什么时刻释放？"><a href="#一个autorealese对象在什么时刻释放？" class="headerlink" title="一个autorealese对象在什么时刻释放？"></a>一个autorealese对象在什么时刻释放？</h3><p>1、AutoRelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前runloop迭代结束时释放。本质上说本次runloop迭代结束时清理到本次迭代期间内被放到autorelease pool中的对象。</p><p> 2、一个autorealese对象在什么时刻释放?分两种情况：手动干预释放时机–指定autoreleasepool 就是所谓的：当前作用域大括号结束时释放。系统自动去释放。</p><p> 3、创建自动释放池的时机？运行循环检测到事件并启动后，就会创建自动释放池。</p><p>  4、子线程默认是没有Runloop的，编程人员在调用 [NSRunLoop CurrentRunLoop] 时，是以懒加载的形式自动创建 RunLoop 的，而没法手动创建。</p><p>5、arc下使用@autoreleasepool{} 的意义？</p><pre><code> // 其中如果字符串的数量少于10个，字符串会存放到常量区，所以无论你for多少次，少于10个字符串的对象在内存只生成一次。 //反之，字符串的数量大于或等于10个的时候，就会在堆区生成1024*1024*30个内存对象。for (int index = 0; index &lt; 30 * 1024 * 1024; index ++) {    // 产生大量临时变量时，避免内存使用峰值过高，及时释放内存。    NSString * str = [NSString stringWithFormat:@&quot;0123456789&quot;];}for (int index = 0; index &lt; 30 * 1024 * 1024; index ++) {    @autoreleasepool {        NSString * str = [NSString stringWithFormat:@&quot;0123456789&quot;];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;objc使用什么机制管理对象内存？&quot;&gt;&lt;a href=&quot;#objc使用什么机制管理对象内存？&quot; class=&quot;headerlink&quot; title=&quot;objc使用什么机制管理对象内存？&quot;&gt;&lt;/a&gt;objc使用什么机制管理对象内存？&lt;/h3&gt;&lt;p&gt;通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。&lt;/p&gt;
&lt;h3 id=&quot;ARC通过什么方式帮助开发者管理内存？&quot;&gt;&lt;a href=&quot;#ARC通过什么方式帮助开发者管理内存？&quot; class=&quot;headerlink&quot; title=&quot;ARC通过什么方式帮助开发者管理内存？&quot;&gt;&lt;/a&gt;ARC通过什么方式帮助开发者管理内存？&lt;/h3&gt;&lt;p&gt;ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。&lt;br&gt; 在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中常用的几种_持久化存储方式</title>
    <link href="https://www.wangqian.ltd/2020/04/03/oc-develop-store/"/>
    <id>https://www.wangqian.ltd/2020/04/03/oc-develop-store/</id>
    <published>2020-04-03T08:14:29.000Z</published>
    <updated>2020-04-03T08:31:18.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iOS中常用的持久化存储方式有好几种：</p><ul><li>偏好设置(NSUserDefaults)</li><li>plist文件存储</li><li>归档</li><li>SQLite3</li><li>Core Data</li><li>KeyChain<h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3></li></ul><p>每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录)，与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。沙盒下的目录如下：</p><ul><li>Application：存放程序源文件，上架前经过数字签名，上架后不可修改</li><li>Documents: 保存应⽤运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录。例如,游戏应用可将游戏存档保存在该目录</li><li>tmp: 保存应⽤运行时所需的临时数据,使⽤完毕后再将相应的文件从该目录删除。应用 没有运行时,系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。</li><li>Library/Caches: 保存应用运行时⽣成的需要持久化的数据,iTunes同步设备时不会备份 该目录。⼀一般存储体积大、不需要备份的非重要数据，比如网络数据缓存存储到Caches下</li><li>Library/Preference: 保存应用的所有偏好设置，如iOS的Settings(设置) 应⽤会在该目录中查找应⽤的设置信息。iTunes同步设备时会备份该目录</li><li><a id="more"></a></li></ul><h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>NSUserDefaults是个单例类，用于存储少量数据。NSUserDefaults实际上对plist文件操作的封装，更方便我们直接操作，一般用于存储系统级别的偏好设置。比如我们经常将登录后的用户的一些设置通过NSUserDefaults存储到plist文件中。</p><h3 id="plist存储"><a href="#plist存储" class="headerlink" title="plist存储"></a>plist存储</h3><p>主要保存的数据类型为NSString、NSNumber、NSData、NSArray、NSDictionary、NSMutableArray、NSMutableDictionary、NSMutableData.有的时候，我们需要将下载的数据存储到文件中存储起来，比如，有时候我们将下载起来的城市的数据存储到本地，当更新城市的顺序时，下次也能够按照最后一次操作的顺序来显示出来。</p><h3 id="归档-NSKeyedArchiver"><a href="#归档-NSKeyedArchiver" class="headerlink" title="归档(NSKeyedArchiver)"></a>归档(NSKeyedArchiver)</h3><p>一般保存自定义的对象，自定义对象数组，但是只有遵守NSCoding的类才能只用归档。如果使用MJExtension可以不用写复杂的NSCoding协议，只需要一句MJCodingImplementation即可。</p><h3 id="KeyChain"><a href="#KeyChain" class="headerlink" title="KeyChain"></a>KeyChain</h3><p>用来存加密数据，这个与其他存储方式不同的是：即使删除掉app数据也不会消失，因为它存在一个/private/var/keychains/keychain-2.db的数据库文件中，这是一个系统文件，所以删除app，它不会消失。不过不适合大量数据的持久化存储</p><h3 id="CoreData"><a href="#CoreData" class="headerlink" title="CoreData"></a>CoreData</h3><p>对象持久化，用来保存程序用到的对象及对象间的关联。CoreData是对SQLite的封装,本质还是数据库存储，将OC对象转化成数据保存在数据库中。好处就是能够合理管理内存，避免sql语句的麻烦</p><h3 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h3><p>SQLite是一款轻型的嵌入式数据库，安卓和ios开发使用的都是SQLite数据库.</p><p>iOS中原生的SQLite API在进行数据存储的时候，需要使用C语言中的函数，操作比较麻烦，于是就出现了一系列将SQLite封装的库。本文讲解的FMDB就是其中的一个。<br>优点:</p><ol><li><p>对多线程的并发操作进行了处理，所以是线程安全的</p></li><li><p>以OC的方式封装了SQLite的C语言API，使用起来更加方便</p></li><li><p>FMDB是轻量级框架 使用灵活</p></li></ol><p>缺点:</p><p>因为它是OC的语言封装的，只能在ios开发的时候使用，所以在实现跨平台操作的时候存在局限性。 </p><p>日常使用WCDB：<a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">https://github.com/Tencent/wcdb/wiki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;iOS中常用的持久化存储方式有好几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏好设置(NSUserDefaults)&lt;/li&gt;
&lt;li&gt;plist文件存储&lt;/li&gt;
&lt;li&gt;归档&lt;/li&gt;
&lt;li&gt;SQLite3&lt;/li&gt;
&lt;li&gt;Core Data&lt;/li&gt;
&lt;li&gt;KeyChain&lt;h3 id=&quot;沙盒&quot;&gt;&lt;a href=&quot;#沙盒&quot; class=&quot;headerlink&quot; title=&quot;沙盒&quot;&gt;&lt;/a&gt;沙盒&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录)，与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。沙盒下的目录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Application：存放程序源文件，上架前经过数字签名，上架后不可修改&lt;/li&gt;
&lt;li&gt;Documents: 保存应⽤运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录。例如,游戏应用可将游戏存档保存在该目录&lt;/li&gt;
&lt;li&gt;tmp: 保存应⽤运行时所需的临时数据,使⽤完毕后再将相应的文件从该目录删除。应用 没有运行时,系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。&lt;/li&gt;
&lt;li&gt;Library/Caches: 保存应用运行时⽣成的需要持久化的数据,iTunes同步设备时不会备份 该目录。⼀一般存储体积大、不需要备份的非重要数据，比如网络数据缓存存储到Caches下&lt;/li&gt;
&lt;li&gt;Library/Preference: 保存应用的所有偏好设置，如iOS的Settings(设置) 应⽤会在该目录中查找应⽤的设置信息。iTunes同步设备时会备份该目录&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>runloop</title>
    <link href="https://www.wangqian.ltd/2020/04/02/oc-develop-runloop/"/>
    <id>https://www.wangqian.ltd/2020/04/02/oc-develop-runloop/</id>
    <published>2020-04-02T09:58:34.000Z</published>
    <updated>2020-04-02T10:22:30.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runloop和线程有什么关系？"><a href="#runloop和线程有什么关系？" class="headerlink" title="runloop和线程有什么关系？"></a>runloop和线程有什么关系？</h3><p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要.每个线程包括程序的主线程（main thread）都有与之对应的run loop对象。</p><p>1、主线程的run loop默认是启动的。</p><p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p><pre><code>int main(int argc, char * argv[]) {   @autoreleasepool {   return UIApplicationMain(argc, argv, nil,     NSStringFromClass([AppDelegate class]));   }}</code></pre><p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p><p>2、对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p><p>3、在任何一个Cocoa程序的线程中，都可以通过以下代码获取当前线程的run loop</p><pre><code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code></pre><a id="more"></a><h3 id="runloop的mode作用是什么？"><a href="#runloop的mode作用是什么？" class="headerlink" title="runloop的mode作用是什么？"></a>runloop的mode作用是什么？</h3><p>model 主要是用来指定事件在运行循环的优先级，分为：</p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li><li>UITrackingRunLoopMode：ScrollView滑动时</li><li>UIInitializationRunLoopMode：启动时</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li></ul><p>苹果公开提供的 Mode 有两个： </p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li></ul><h3 id="以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>RunLoop只能运行在一种mode下，如果要换mode，当前loop需要重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动。</p><p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p><p>同时因为mode还是可定制的，所以：Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p><pre><code>//将timer添加到NSDefaultRunLoopMode中[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];//然后再添加到NSRunLoopCommonModes里NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></pre><h3 id="猜想runloop内部是如何实现的？"><a href="#猜想runloop内部是如何实现的？" class="headerlink" title="猜想runloop内部是如何实现的？"></a>猜想runloop内部是如何实现的？</h3><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。我们需要一个极致，让线程随时处理事件但不退出。</p><pre><code>int main(int argc, char * argv[]) { //程序一直运行状态 while (AppIsRunning) {  //睡眠状态，等待唤醒事件  id whoWakesMe = SleepForWakingUp();  //得到唤醒事件  id event = GetEvent(whoWakesMe);  //开始处理事件  HandleEvent(event); } return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runloop和线程有什么关系？&quot;&gt;&lt;a href=&quot;#runloop和线程有什么关系？&quot; class=&quot;headerlink&quot; title=&quot;runloop和线程有什么关系？&quot;&gt;&lt;/a&gt;runloop和线程有什么关系？&lt;/h3&gt;&lt;p&gt;总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要.每个线程包括程序的主线程（main thread）都有与之对应的run loop对象。&lt;/p&gt;
&lt;p&gt;1、主线程的run loop默认是启动的。&lt;/p&gt;
&lt;p&gt;iOS的应用程序里面，程序启动后会有一个如下的main()函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(int argc, char * argv[]) {
   @autoreleasepool {
   return UIApplicationMain(argc, argv, nil,     NSStringFromClass([AppDelegate class]));
   }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。&lt;/p&gt;
&lt;p&gt;2、对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。&lt;/p&gt;
&lt;p&gt;3、在任何一个Cocoa程序的线程中，都可以通过以下代码获取当前线程的run loop&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSRunLoop *runloop = [NSRunLoop currentRunLoop];&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 中对 self 和 super 的理解</title>
    <link href="https://www.wangqian.ltd/2020/03/23/oc-develop-selfAndSuper/"/>
    <id>https://www.wangqian.ltd/2020/03/23/oc-develop-selfAndSuper/</id>
    <published>2020-03-23T03:57:55.000Z</published>
    <updated>2020-03-23T04:12:11.203Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Objective-C-中对-self-和-super-的理解"><a href="#Objective-C-中对-self-和-super-的理解" class="headerlink" title="Objective-C 中对 self 和 super 的理解"></a>Objective-C 中对 self 和 super 的理解</h3><pre><code>@implementation Son- (instancetype)init {self = [super init];if (self) {    // 1、self 是类的隐藏参数，指向当前调用方法的这个类的实例    // 2、super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者    // 3、当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法    NSLog(@&quot;%@&quot;,NSStringFromClass([self class]));   // 输出 Son    NSLog(@&quot;%@&quot;,NSStringFromClass([super class]));  // 输出 Son}return self;}</code></pre><p>疑问点：父类中此时若使用点语法（ self.lastName ）也即 setter 设置方法，那么调用将会是子类的设置方法，为什么？</p><a id="more"></a><h3 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h3><p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p><h3 id="使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><p> ARC 、MRC都不需要</p><h3 id="objc中的类方法和实例方法有什么本质区别和联系？"><a href="#objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="objc中的类方法和实例方法有什么本质区别和联系？"></a>objc中的类方法和实例方法有什么本质区别和联系？</h3><p>类方法：</p><ul><li>类方法是属于类对象的</li><li>类方法中的self是类对象</li><li>类方法可以调用其他的类方法</li><li>类方法中不能访问成员变量（类方法中不能访问成员变量、不能调用对象方法）</li><li>类方法中不能直接调用对象方法</li></ul><p>实例方法：</p><ul><li>实例方法是属于实例对象的</li><li>实例方法只能通过实例对象调用</li><li>实例方法中的self是实例对象</li><li>实例方法中可以访问成员变量</li><li>实例方法中直接调用实例方法</li><li>实例方法中也可以调用类方法(通过类名)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Objective-C-中对-self-和-super-的理解&quot;&gt;&lt;a href=&quot;#Objective-C-中对-self-和-super-的理解&quot; class=&quot;headerlink&quot; title=&quot;Objective-C 中对 self 和 super 的理解&quot;&gt;&lt;/a&gt;Objective-C 中对 self 和 super 的理解&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@implementation Son
- (instancetype)init {
self = [super init];
if (self) {

    // 1、self 是类的隐藏参数，指向当前调用方法的这个类的实例
    // 2、super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者
    // 3、当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法
    NSLog(@&amp;quot;%@&amp;quot;,NSStringFromClass([self class]));   // 输出 Son
    NSLog(@&amp;quot;%@&amp;quot;,NSStringFromClass([super class]));  // 输出 Son
}
return self;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;疑问点：父类中此时若使用点语法（ self.lastName ）也即 setter 设置方法，那么调用将会是子类的设置方法，为什么？&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>objc中向一个nil对象发送消息将会发生什么</title>
    <link href="https://www.wangqian.ltd/2020/03/20/oc-develop-objc-sendmsgnil/"/>
    <id>https://www.wangqian.ltd/2020/03/20/oc-develop-objc-sendmsgnil/</id>
    <published>2020-03-20T09:26:49.000Z</published>
    <updated>2020-03-20T09:30:25.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="objc中向一个nil对象发送消息将会发生什么"><a href="#objc中向一个nil对象发送消息将会发生什么" class="headerlink" title="objc中向一个nil对象发送消息将会发生什么"></a>objc中向一个nil对象发送消息将会发生什么</h3><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p><p>objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p><a id="more"></a><p>[obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;objc中向一个nil对象发送消息将会发生什么&quot;&gt;&lt;a href=&quot;#objc中向一个nil对象发送消息将会发生什么&quot; class=&quot;headerlink&quot; title=&quot;objc中向一个nil对象发送消息将会发生什么&quot;&gt;&lt;/a&gt;objc中向一个nil对象发送消息将会发生什么&lt;/h3&gt;&lt;p&gt;在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:&lt;/p&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;/p&gt;
&lt;p&gt;objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一个objc对象如何进行内存布局</title>
    <link href="https://www.wangqian.ltd/2020/03/19/oc-develop-objcmemory/"/>
    <id>https://www.wangqian.ltd/2020/03/19/oc-develop-objcmemory/</id>
    <published>2020-03-19T08:55:48.000Z</published>
    <updated>2020-04-13T08:38:21.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><p>所有的父类的成员变量和自己的成员变量都在该对象所对应的存储空间中。</p><p>每一个对象内部都有一个isa指针指向类对象，类对象存放本对象的以下内容</p><ol><li>对象方法列表</li><li>成员变量列表</li><li>属性列表</li><li>每个类对象内部也有一个isa指针指向元对象（meta class），元对象内部存放 类方法列表</li><li>superclass指针，指向对象的父类对象。<a id="more"></a></li></ol><p>根对象就是NSObject，它的superclass指针指向nil。</p><p>根元类的isa指针指向它自己，superclass指针指向NSObject。</p><img src="/2020/03/19/oc-develop-objcmemory/1.png"><h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向他的类对象,从而可以找到对象上的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个objc对象如何进行内存布局？（考虑有父类的情况）&quot;&gt;&lt;a href=&quot;#一个objc对象如何进行内存布局？（考虑有父类的情况）&quot; class=&quot;headerlink&quot; title=&quot;一个objc对象如何进行内存布局？（考虑有父类的情况）&quot;&gt;&lt;/a&gt;一个objc对象如何进行内存布局？（考虑有父类的情况）&lt;/h3&gt;&lt;p&gt;所有的父类的成员变量和自己的成员变量都在该对象所对应的存储空间中。&lt;/p&gt;
&lt;p&gt;每一个对象内部都有一个isa指针指向类对象，类对象存放本对象的以下内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象方法列表&lt;/li&gt;
&lt;li&gt;成员变量列表&lt;/li&gt;
&lt;li&gt;属性列表&lt;/li&gt;
&lt;li&gt;每个类对象内部也有一个isa指针指向元对象（meta class），元对象内部存放 类方法列表&lt;/li&gt;
&lt;li&gt;superclass指针，指向对象的父类对象。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>runtime消息转发机制</title>
    <link href="https://www.wangqian.ltd/2020/03/18/oc-develop-objc-msgForward/"/>
    <id>https://www.wangqian.ltd/2020/03/18/oc-develop-objc-msgForward/</id>
    <published>2020-03-18T06:53:42.000Z</published>
    <updated>2020-03-18T06:59:51.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么时候会报unrecognized-selector的异常？"><a href="#什么时候会报unrecognized-selector的异常？" class="headerlink" title="什么时候会报unrecognized selector的异常？"></a>什么时候会报unrecognized selector的异常？</h3><p>简单来说：</p><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。简单的流程如下，</p><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。<br>objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p><a id="more"></a><h4 id="1、Method-resolution"><a href="#1、Method-resolution" class="headerlink" title="1、Method resolution"></a>1、Method resolution</h4><p>objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p><h4 id="2、Fast-forwarding"><a href="#2、Fast-forwarding" class="headerlink" title="2、Fast forwarding"></a>2、Fast forwarding</h4><p>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p><h4 id="3、Normal-forwarding"><a href="#3、Normal-forwarding" class="headerlink" title="3、Normal forwarding"></a>3、Normal forwarding</h4><p>这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</p><p>为了能更清晰地理解这些方法的作用，请参demo：_objc_msgForward_demo</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么时候会报unrecognized-selector的异常？&quot;&gt;&lt;a href=&quot;#什么时候会报unrecognized-selector的异常？&quot; class=&quot;headerlink&quot; title=&quot;什么时候会报unrecognized selector的异常？&quot;&gt;&lt;/a&gt;什么时候会报unrecognized selector的异常？&lt;/h3&gt;&lt;p&gt;简单来说：&lt;/p&gt;
&lt;p&gt;当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。简单的流程如下，&lt;/p&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;br&gt;objc在向一个对象发送消息时，runtime库寻找对象的isa指针，然后根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>synthesize和dynamic分别有什么作用？</title>
    <link href="https://www.wangqian.ltd/2020/03/05/synthesizeAnddynamic/"/>
    <id>https://www.wangqian.ltd/2020/03/05/synthesizeAnddynamic/</id>
    <published>2020-03-05T08:20:14.000Z</published>
    <updated>2020-03-11T06:57:32.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a>@synthesize和@dynamic分别有什么作用？</h3><ol><li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</li><li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法</li><li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃.</li><li>动态绑定:编译时没有问题，运行时才执行相应的方法。</li></ol><a id="more"></a><h3 id="在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p><ol><li>同时重写了 setter 和 getter 时</li><li>重写了只读属性的 getter 时</li><li>使用了 @dynamic 时</li><li>在 @protocol 中定义的所有属性</li><li>在 category 中定义的所有属性</li><li>重载的属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 实例变量 = 成员变量 ＝ ivar</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,readwrite,copy) NSString *firstName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController &#123;</span><br><span class="line">//    NSString *_firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//@synthesize firstName = _firstName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFirstName:(NSString *)firstName &#123;</span><br><span class="line">    _firstName  = [firstName copy];</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)firstName &#123;</span><br><span class="line">    return _firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p><ol><li>要么如第09行：手动创建 ivar</li><li>要么如第12行：使用@synthesize foo = _foo;关联 @property 与 ivar。</li></ol><h3 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p>1、对应基本数据类型默认关键字是 ：atomic,readwrite,assign<br>2、对于普通的 Objective-C对象是 ：atomic,readwrite,strong</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synthesize和-dynamic分别有什么作用？&quot;&gt;&lt;a href=&quot;#synthesize和-dynamic分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;@synthesize和@dynamic分别有什么作用？&quot;&gt;&lt;/a&gt;@synthesize和@dynamic分别有什么作用？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;&lt;/li&gt;
&lt;li&gt;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法&lt;/li&gt;
&lt;li&gt;@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃.&lt;/li&gt;
&lt;li&gt;动态绑定:编译时没有问题，运行时才执行相应的方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>property的本质</title>
    <link href="https://www.wangqian.ltd/2019/12/30/oc-develop-properyt/"/>
    <id>https://www.wangqian.ltd/2019/12/30/oc-develop-properyt/</id>
    <published>2019-12-30T07:14:49.000Z</published>
    <updated>2020-03-05T07:12:45.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="property-的本质是什么"><a href="#property-的本质是什么" class="headerlink" title="@property 的本质是什么"></a>@property 的本质是什么</h3><p>1、“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p><p>2、property在runtime中是objc_property_t定义：</p><p>typedef struct objc_property *objc_property_t;</p><a id="more"></a><h3 id="weak属性需要在dealloc中置nil么？"><a href="#weak属性需要在dealloc中置nil么？" class="headerlink" title="weak属性需要在dealloc中置nil么？"></a>weak属性需要在dealloc中置nil么？</h3><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理. </p><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p><h3 id="ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="ivar、getter、setter 是如何生成并添加到这个类中的?"></a>ivar、getter、setter 是如何生成并添加到这个类中的?</h3><p>“自动合成”( autosynthesis)</p><p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)</p><p>也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h3><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt; /*或者 #import &lt;objc/message.h&gt;*/</span><br><span class="line">static NSString *nameKey = @&quot;nameKey&quot;; //那么的key</span><br><span class="line"></span><br><span class="line">@interface NSObject ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Person)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> setter方法</span><br><span class="line"> */</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;nameKey, name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> getter方法</span><br><span class="line"> */</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;nameKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>分类并不会改变原有类的内存分布的情况，它是在运行期间决定的，此时内存的分布已经确定，若此时再添加实例会改变内存的分布情况，这对编译性语言是灾难，是不允许的。反观扩展(extension)，作用是为一个已知的类添加一些私有的信息，必须有这个类的源码，才能扩展，它是在编译器生效的，所以能直接为类添加属性或者实例变量。</p><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性。</p><h3 id="类扩展（Class-Extension）"><a href="#类扩展（Class-Extension）" class="headerlink" title="类扩展（Class Extension）"></a>类扩展（Class Extension）</h3><p>Extension是Category的一个特例。类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。</p><p>其实开发当中，我们几乎天天在使用。对于有些人来说像是最熟悉的陌生人。作用是：为一个类添加额外的原来没有变量，方法和属性。</p><pre><code>@interface XXX ()//私有属性//私有方法（如果不实现，编译时会报警,Method definition     for &apos;XXX&apos; not found）@end</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;property-的本质是什么&quot;&gt;&lt;a href=&quot;#property-的本质是什么&quot; class=&quot;headerlink&quot; title=&quot;@property 的本质是什么&quot;&gt;&lt;/a&gt;@property 的本质是什么&lt;/h3&gt;&lt;p&gt;1、“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。&lt;/p&gt;
&lt;p&gt;2、property在runtime中是objc_property_t定义：&lt;/p&gt;
&lt;p&gt;typedef struct objc_property *objc_property_t;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何让自己的类用 copy 修饰符？</title>
    <link href="https://www.wangqian.ltd/2019/12/16/oc-develop-nscopying/"/>
    <id>https://www.wangqian.ltd/2019/12/16/oc-develop-nscopying/</id>
    <published>2019-12-16T07:01:20.000Z</published>
    <updated>2019-12-16T07:11:44.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何让自己的类用-copy-修饰符？"><a href="#如何让自己的类用-copy-修饰符？" class="headerlink" title="如何让自己的类用 copy 修饰符？"></a>如何让自己的类用 copy 修饰符？</h3><pre><code> NSArray *tempArray = @[@&quot;1&quot;,@&quot;2&quot;];NSMutableArray *mutableCopyMuArray = [tempArray mutableCopy];// tempArray==0x600002649ce  mutableCopyMuArray==0x600002649ce0// 深copy tempArray 和 mutableCopyMuArray是完全不同的变量NSLog(@&quot;tempArray==%p,mutableCopyMuArray==%p&quot;,tempArray,mutableCopyMuArray); WQUser *user = [[WQUser alloc] initWithName:@&quot;lbj&quot; age:35];/* WQUser自己新建的类不具备copy功能，程序会crash 声明NSCopying并且实现协议方法后，新建的类会具备copy功能 user==0x600002f7b400,copyUser==0x600002f7b3e0，copy出来完全不同的变量 */WQUser *copyUser = [user copy];NSLog(@&quot;user==%p,copyUser==%p&quot;,user,copyUser);</code></pre><a id="more"></a><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p><p>具体步骤：</p><ol><li>需声明该类遵从 NSCopying 协议</li><li>实现 NSCopying 协议。该协议只有一个方法:</li></ol><pre><code>#import &quot;WQUser.h&quot;@interface WQUser ()&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readwrite, strong) NSMutableSet *friends;@end@implementation WQUser- (instancetype)initWithName:(NSString *)name                 age:(NSUInteger)age {if (self = [super init]) {_name = [name copy];_age = age;_friends = [[NSMutableSet alloc] init];}return self;}    #pragma mark - NSCopying- (id)copyWithZone:(nullable NSZone *)zone {WQUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age];copy.friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:true];return copy;}    @end    </code></pre><h3 id="如何重写带-copy-关键字的-setter？"><a href="#如何重写带-copy-关键字的-setter？" class="headerlink" title="如何重写带 copy 关键字的 setter？"></a>如何重写带 copy 关键字的 setter？</h3><pre><code>/* 不要在 setter 里进行像 if(_obj != newObj) 这样的判断 什么情况会在 copy setter 里做 if 判断？ 例如，车速可能就    有最高速的限制，车速也不可能出现负值，如果车子的最高速为    300，则 setter 的方法就要改写成这样：     - (void)setSpeed:(int)_speed{ if(_speed &lt; 0) speed = 0; if(_speed &gt; 300) speed = 300; _speed = speed; } */- (void)setName:(NSString *)name {//[_name release]; // MRC_name = [name copy];}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何让自己的类用-copy-修饰符？&quot;&gt;&lt;a href=&quot;#如何让自己的类用-copy-修饰符？&quot; class=&quot;headerlink&quot; title=&quot;如何让自己的类用 copy 修饰符？&quot;&gt;&lt;/a&gt;如何让自己的类用 copy 修饰符？&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; NSArray *tempArray = @[@&amp;quot;1&amp;quot;,@&amp;quot;2&amp;quot;];
NSMutableArray *mutableCopyMuArray = [tempArray mutableCopy];

// tempArray==0x600002649ce  mutableCopyMuArray==0x600002649ce0
// 深copy tempArray 和 mutableCopyMuArray是完全不同的变量
NSLog(@&amp;quot;tempArray==%p,mutableCopyMuArray==%p&amp;quot;,tempArray,mutableCopyMuArray);


 WQUser *user = [[WQUser alloc] initWithName:@&amp;quot;lbj&amp;quot; age:35];
/*
 WQUser自己新建的类不具备copy功能，程序会crash
 声明NSCopying并且实现协议方法后，新建的类会具备copy功能
 user==0x600002f7b400,copyUser==0x600002f7b3e0，copy出来完全不同的变量
 */

WQUser *copyUser = [user copy];

NSLog(@&amp;quot;user==%p,copyUser==%p&amp;quot;,user,copyUser);&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>关键字</title>
    <link href="https://www.wangqian.ltd/2019/12/10/oc-develop-keyword/"/>
    <id>https://www.wangqian.ltd/2019/12/10/oc-develop-keyword/</id>
    <published>2019-12-10T03:46:42.000Z</published>
    <updated>2019-12-10T04:32:13.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><p>什么情况使用 weak 关键字？</p><ol><li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li><li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak</li></ol><p>不同点：</p><ol><li>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</li><li>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象<a id="more"></a></li></ol><h3 id="使用-copy-关键字"><a href="#使用-copy-关键字" class="headerlink" title="使用 copy 关键字"></a>使用 copy 关键字</h3><p>用途:</p><ol><li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li><li>block 也经常使用 copy 关键字.</li></ol><p>解释：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p><h3 id="copy和mutableCopy区别和用法"><a href="#copy和mutableCopy区别和用法" class="headerlink" title="copy和mutableCopy区别和用法"></a>copy和mutableCopy区别和用法</h3><h4 id="浅拷贝（互相影响）"><a href="#浅拷贝（互相影响）" class="headerlink" title="浅拷贝（互相影响）"></a>浅拷贝（互相影响）</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的</p><h4 id="单层深拷贝"><a href="#单层深拷贝" class="headerlink" title="单层深拷贝"></a>单层深拷贝</h4><p>对于不可变的容器类对象(如NSArray、NSSet、NSDictionary)进 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化，属于单层深拷贝。<br>对于可变集合类对象(如NSMutableArray、NSMutableSet、NSMutableDictionary)，不管是进行 copy 操作还是 mutableCopy 操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p><h4 id="深拷贝（互不影响）"><a href="#深拷贝（互不影响）" class="headerlink" title="深拷贝（互不影响）"></a>深拷贝（互不影响）</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p><h4 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h4><p>非集合类对象的 copy 和 mutableCopy<br>我们对一个 NSString 属性进行 copy 和 mutableCopy –》对 NSString 进行 copy 操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行 mutableCopy 操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的 copy 操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。<br>NSMutableString 进行 copy 和 mutableCopy  –》对 NSMutableString 进行 copy 操作，其内存地址和指针地址都发生了变化，所以操作是深拷贝，和上面有所不同；进行 mutableCopy 操作，其内存地址和指针地址也都发生了变化，所以也是深拷贝。</p><p>总结：在非集合类对象中，对不可变对象进行 copy 操作，只仅仅是指针复制，进行 mutableCopy 操作，是内容复制。<br>对可变对象进行 copy 和 mutableCopy 操作，都是内容复制。</p><p>集合类对象的 copy 和 mutableCopy<br>对于不可变的集合类对象进行 copy 操作，只是改变了指针，其内存地址并没有发生变化；进行 mutableCopy 操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。（单层深拷贝）<br>对于可变集合类对象，不管是进行 copy 操作还是 mutableCopy 操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p><p>总结：</p><ol><li>NSMutableArray多次copy每次都会新建对象而NSArray多次copy只新建一次对象。5</li><li>对于容器而言，其元素对象始终是指针复制,归档的方法实现了真正的元素对象拷贝</li><li>容器内元素对象的唯一性。从数组中取出一个可变字符串，然后修改字符串对象，直接打印数组，数组中的这个字符串元素也会发生改变。</li><li>NSArray * array1 = @[@”1”,@”2”,@”3”];  NSArray * array2 = array1;  //  只是单纯的多一个指针指向</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么情况使用-weak-关键字，相比-assign-有什么不同？&quot;&gt;&lt;a href=&quot;#什么情况使用-weak-关键字，相比-assign-有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;什么情况使用 weak 关键字，相比 assign 有什么不同？&quot;&gt;&lt;/a&gt;什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/h3&gt;&lt;p&gt;什么情况使用 weak 关键字？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性&lt;/li&gt;
&lt;li&gt;自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。&lt;/li&gt;
&lt;li&gt;assign 可以用非 OC 对象,而 weak 必须用于 OC 对象&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Go语言常量和模拟枚举</title>
    <link href="https://www.wangqian.ltd/2019/11/22/GolangBasis-day06/"/>
    <id>https://www.wangqian.ltd/2019/11/22/GolangBasis-day06/</id>
    <published>2019-11-22T07:17:38.000Z</published>
    <updated>2019-11-22T07:35:56.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、常量和const关键字"><a href="#1、常量和const关键字" class="headerlink" title="1、常量和const关键字"></a>1、常量和const关键字</h3><p>特点：</p><ul><li>常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此。</li><li>const定义类型只有基本数据类型。string bool 数字（整型、浮点型、复数）</li><li>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</li></ul><a id="more"></a><p>变量三种命名方式：</p><pre><code>var num1 int = 3var num2 = 4num3 := 5</code></pre><p>常量定义格式：和变量的声明语法类似。</p><pre><code>显式类型定义： const b string = &quot;abc&quot;隐式类型定义： const b = &quot;abc&quot;    </code></pre><h3 id="2、iota-常量生成器（枚举类型）"><a href="#2、iota-常量生成器（枚举类型）" class="headerlink" title="2、iota 常量生成器（枚举类型）"></a>2、iota 常量生成器（枚举类型）</h3><pre><code>type Weekday intconst (Sunday Weekday = iotaMondayTuesdayWednesdayThursdayFridaySaturday)</code></pre><h3 id="2-1-将枚举值转换为字符串"><a href="#2-1-将枚举值转换为字符串" class="headerlink" title="2.1 将枚举值转换为字符串"></a>2.1 将枚举值转换为字符串</h3><p>当这个类型需要显示为字符串时，Go语言会自动寻找String()方法并进行调用。</p><h3 id="3、无类型常量"><a href="#3、无类型常量" class="headerlink" title="3、无类型常量"></a>3、无类型常量</h3><p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><pre><code>示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：    var x float32 = math.Pi    var y float64 = math.Pi    var z complex128 = math.Pi    如果 math.Pi 被确定为特定类型，比如 float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要一个明确的强制类型转换：    const Pi64 float64 = math.Pi    var x float32 = float32(Pi64) 强制类型转换方式语法和其他语言不同    var y float64 = Pi64    var z complex128 = complex128(Pi64)</code></pre><p>参考地址：<a href="http://c.biancheng.net/view/24.html" target="_blank" rel="noopener">http://c.biancheng.net/view/24.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、常量和const关键字&quot;&gt;&lt;a href=&quot;#1、常量和const关键字&quot; class=&quot;headerlink&quot; title=&quot;1、常量和const关键字&quot;&gt;&lt;/a&gt;1、常量和const关键字&lt;/h3&gt;&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此。&lt;/li&gt;
&lt;li&gt;const定义类型只有基本数据类型。string bool 数字（整型、浮点型、复数）&lt;/li&gt;
&lt;li&gt;常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mac下升级ruby环境版本</title>
    <link href="https://www.wangqian.ltd/2019/11/18/updateRuby/"/>
    <id>https://www.wangqian.ltd/2019/11/18/updateRuby/</id>
    <published>2019-11-18T09:57:07.000Z</published>
    <updated>2019-11-18T10:04:05.291Z</updated>
    
    <content type="html"><![CDATA[<p>在ios开发中会经常使用到cocoapods来管理第三方框架，在安装cocoapods的时候会涉及到ruby环境，有时候会因为版本过低会导致安装失败，本文主要讲一下如何升级ruby环境</p><a id="more"></a><p>安装rvm，rvm是可以让你拥有很多ruby版本的一个工具，具体的可以去了解一下（以下各个步骤均在terminal中实现） </p><pre><code>$ curl -L https://get.rvm.io | bash -s stable</code></pre><p>期间可能会问你sudo管理员密码，这里可能需要等待一段时间后就可以成功安装好 RVM</p><p>载入rvm环境</p><pre><code>$ source ~/.rvm/scripts/rvm</code></pre><p>检查是否安装成功，输入下面命令出现版本号等信息表示安装成功</p><pre><code>$ rvm -v</code></pre><p>用rvm安装ruby环境</p><pre><code>$ rvm install 2.2.4</code></pre><p>设置为默认版本</p><pre><code>$ rvm use 2.2.4 --default</code></pre><p>补充一些常用命令</p><p>rvm list 查看已安装ruby</p><p>rvm list known 列出ruby可安装版本信息</p><p>rvm remove 2.2.2 卸载一个已安装的ruby版本</p><p>gem source 查看已有源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ios开发中会经常使用到cocoapods来管理第三方框架，在安装cocoapods的时候会涉及到ruby环境，有时候会因为版本过低会导致安装失败，本文主要讲一下如何升级ruby环境&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/categories/GitHub/"/>
    
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Golang疑问</title>
    <link href="https://www.wangqian.ltd/2019/11/14/ColangQuestion/"/>
    <id>https://www.wangqian.ltd/2019/11/14/ColangQuestion/</id>
    <published>2019-11-14T09:47:43.000Z</published>
    <updated>2019-11-14T09:49:28.445Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、变量逃逸分析，不太明白变量是在栈、堆上？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、变量逃逸分析，不太明白变量是在栈、堆上？&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang语言指针</title>
    <link href="https://www.wangqian.ltd/2019/11/13/GolangBasis-day05/"/>
    <id>https://www.wangqian.ltd/2019/11/13/GolangBasis-day05/</id>
    <published>2019-11-13T09:33:37.000Z</published>
    <updated>2019-11-13T09:44:28.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>名词：指针类型、指针地址、&amp;、*</p><pre><code>//  ptr-pointer (既指针)得缩写var house string = &quot;777&quot;ptr := &amp;house // &amp;取地址操作符,对字符串取地址，将指针保存到变量ptr中fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)    // 指针类型为 *stringfmt.Printf(&quot;ptr address: %p\n&quot;, ptr) // 指针地址，指向对象在内存中存放的位置。每次运行都会发生变化。value := *ptr                         // *取值操作符，对指针进行取值操作fmt.Printf(&quot;value type: %T\n&quot;, value) // 打印为stringfmt.Printf(&quot;value address: %s\n&quot;, value)</code></pre><a id="more"></a><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><h3 id="使用指针变量获取命令行的输入信息"><a href="#使用指针变量获取命令行的输入信息" class="headerlink" title="使用指针变量获取命令行的输入信息"></a>使用指针变量获取命令行的输入信息</h3><pre><code>var mode = flag.String(&quot;mode&quot;, &quot;&quot;, &quot;process mode&quot;)flag.Parse()fmt.Println(*mode)go run src/day_02/Bool类型/bool.go --mode=7</code></pre><h3 id="创建指针的另一种方法-new-函数"><a href="#创建指针的另一种方法-new-函数" class="headerlink" title="创建指针的另一种方法 new()函数"></a>创建指针的另一种方法 new()函数</h3><pre><code>//用法如下：str2 := new(string)*str2 = &quot;加油加油&quot;fmt.Printf(&quot;%s\n&quot;, *str2) // 加油加油</code></pre><p>参考地址：<a href="http://c.biancheng.net/view/21.html" target="_blank" rel="noopener">http://c.biancheng.net/view/21.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;从指针获取指针指向的值&quot;&gt;&lt;a href=&quot;#从指针获取指针指向的值&quot; class=&quot;headerlink&quot; title=&quot;从指针获取指针指向的值&quot;&gt;&lt;/a&gt;从指针获取指针指向的值&lt;/h3&gt;&lt;p&gt;名词：指针类型、指针地址、&amp;amp;、*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//  ptr-pointer (既指针)得缩写

var house string = &amp;quot;777&amp;quot;

ptr := &amp;amp;house // &amp;amp;取地址操作符,对字符串取地址，将指针保存到变量ptr中

fmt.Printf(&amp;quot;ptr type: %T\n&amp;quot;, ptr)    // 指针类型为 *string
fmt.Printf(&amp;quot;ptr address: %p\n&amp;quot;, ptr) // 指针地址，指向对象在内存中存放的位置。每次运行都会发生变化。

value := *ptr                         // *取值操作符，对指针进行取值操作
fmt.Printf(&amp;quot;value type: %T\n&amp;quot;, value) // 打印为string
fmt.Printf(&amp;quot;value address: %s\n&amp;quot;, value)&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基本语法</title>
    <link href="https://www.wangqian.ltd/2019/09/19/GolangBasis-day04/"/>
    <id>https://www.wangqian.ltd/2019/09/19/GolangBasis-day04/</id>
    <published>2019-09-19T11:36:16.000Z</published>
    <updated>2019-10-14T10:10:39.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go语言类型的本质"><a href="#Go语言类型的本质" class="headerlink" title="Go语言类型的本质"></a>Go语言类型的本质</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>整型类型、浮点类型、字符串类型和布尔类型，对这些值进行增加或者删除的时候，会创建一个新值。当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>疑问点：<br>1、这些值进行增加或者删除的时候，会创建一个新值<br>2、引用类型、结构类型没看</p><a id="more"></a><h3 id="bool类型知识点"><a href="#bool类型知识点" class="headerlink" title="bool类型知识点"></a>bool类型知识点</h3><p>1、Go语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，否则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。</p><p>2、&amp;&amp; 的优先级比 || 高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）</p><p>3、布尔值并不会隐式转换为数字值 0 或 1，反之亦然。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>基本理解：字符串是字符的一个序列，字符是UTF-8编码格式。当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节。</p><h4 id="工具用法"><a href="#工具用法" class="headerlink" title="工具用法"></a>工具用法</h4><p>1、ASCII字符串长度使用len()函数。一个中文三个长度。</p><p>Unicode字符串长度使用utf8.RuneCountlnString()函数。</p><pre><code>var asciiStr string = &quot;abcd&quot;fmt.Println(len(asciiStr))fmt.Println(utf8.RuneCountInString(asciiStr))chineseStr := &quot;王乾&quot;fmt.Printf(&quot;%d\n&quot;, len(chineseStr))fmt.Println(utf8.RuneCountInString(chineseStr))输出结果：    wangqiandeMacBook-Pro:Golang_Study wangqian$ go run src/day_02/Bool类型/bool.go    4    4    6    2</code></pre><p>2、字符串检索</p><pre><code>strings.Index：正向搜索子字符串。strings.LastIndex：反向搜索子字符串。str1[0] 字符对应的ASCII编码表str1[0:] 以位置为0字符开始到结尾字符组成的字符串</code></pre><p>3、字符串遍历的两种方法</p><pre><code>ASCII 字符串遍历直接使用下标。Unicode字符串遍历用for rangeprintf(&quot;%c&quot;,a)；输出单个字符。printf(&quot;%d&quot;,a)；输出十进制整数。printf(&quot;%f&quot;,a)；输出十进制浮点数.printf(&quot;%s&quot;,a)；输出字符串。</code></pre><p>4、GO语言修改字符串</p><pre><code>Go语言中的字符串和其他高级语言（Java、C#）一样，默认是不可变的修改字符串时，可以将字符串转换为 []byte 进行修改。（是重新生成了一个字符串）</code></pre><p>5、字符串拼接方式</p><pre><code> 1、+拼接 2、使用字节缓冲拼接字符串 bytes.Buffer var stringBuffer bytes.Bufferstring1 := &quot;hhhh&quot;string2 := &quot;王乾&quot;stringBuffer.WriteString(string1)stringBuffer.WriteString(string2)fmt.Println(stringBuffer.String())</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Go语言类型的本质&quot;&gt;&lt;a href=&quot;#Go语言类型的本质&quot; class=&quot;headerlink&quot; title=&quot;Go语言类型的本质&quot;&gt;&lt;/a&gt;Go语言类型的本质&lt;/h3&gt;&lt;h4 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; title=&quot;内置类型&quot;&gt;&lt;/a&gt;内置类型&lt;/h4&gt;&lt;p&gt;整型类型、浮点类型、字符串类型和布尔类型，对这些值进行增加或者删除的时候，会创建一个新值。当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。&lt;/p&gt;
&lt;h4 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h4&gt;&lt;h4 id=&quot;结构类型&quot;&gt;&lt;a href=&quot;#结构类型&quot; class=&quot;headerlink&quot; title=&quot;结构类型&quot;&gt;&lt;/a&gt;结构类型&lt;/h4&gt;&lt;p&gt;疑问点：&lt;br&gt;1、这些值进行增加或者删除的时候，会创建一个新值&lt;br&gt;2、引用类型、结构类型没看&lt;/p&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo无法显示本地图片</title>
    <link href="https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/"/>
    <id>https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/</id>
    <published>2019-08-28T05:46:56.000Z</published>
    <updated>2019-08-28T06:18:27.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插件安装与配置"><a href="#1、插件安装与配置" class="headerlink" title="1、插件安装与配置"></a>1、插件安装与配置</h3><p>首先我们需要安装一个图片转化的插件，这个插件的名字叫 <font color="#000000">hexo-asset-image</font></p><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>但是这个插件的内容需要修改【不然可能会出Bug】<br>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre><code>&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data){  var config = hexo.config;  if(config.post_asset_folder){    var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)   var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;else   var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;link = link.substring(beginPos, endPos);var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;];for(var i = 0; i &lt; toprocess.length; i++){  var key = toprocess[i];  var $ = cheerio.load(data[key], {    ignoreWhitespace: false,    xmlMode: false,    lowerCaseTags: false,    decodeEntities: false  });  $(&apos;img&apos;).each(function(){    if ($(this).attr(&apos;src&apos;)){        // For windows style path, we replace &apos;\&apos; to &apos;/&apos;.        var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;);        if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;           !/^\s*\//.test(src)) {          // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed.          // In addition, to support multi-level local directory.          var linkArray = link.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos;;          });          var srcArray = src.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;;          });          if(srcArray.length &gt; 1)            srcArray.shift();          src = srcArray.join(&apos;/&apos;);          $(this).attr(&apos;src&apos;, config.root + link + src);          console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);        }    }else{        console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);        console.info&amp;&amp;console.info($(this));    }  });  data[key] = $.html();}  }});</code></pre><p>最后打开_config.yml文件，修改下述内容</p><pre><code>post_asset_folder: true</code></pre><h3 id="2、相对路径引用的标签插件"><a href="#2、相对路径引用的标签插件" class="headerlink" title="2、相对路径引用的标签插件"></a>2、相对路径引用的标签插件</h3><p>存档页和主页不能使用和文章内容中的常规语法来引用图片。<br>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><pre><code>{% asset_img example.jpg This is an example image %}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、插件安装与配置&quot;&gt;&lt;a href=&quot;#1、插件安装与配置&quot; class=&quot;headerlink&quot; title=&quot;1、插件安装与配置&quot;&gt;&lt;/a&gt;1、插件安装与配置&lt;/h3&gt;&lt;p&gt;首先我们需要安装一个图片转化的插件，这个插件的名字叫 &lt;font color=&quot;#0
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="HEXO" scheme="https://www.wangqian.ltd/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>iPhone和iPad分辨率</title>
    <link href="https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/"/>
    <id>https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/</id>
    <published>2019-08-22T08:02:28.000Z</published>
    <updated>2019-08-23T05:13:31.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iPhone和iPad分辨率"><a href="#iPhone和iPad分辨率" class="headerlink" title="iPhone和iPad分辨率"></a>iPhone和iPad分辨率</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/1.png" title="分辨率"><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPhone.png" title="iPhone"><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPad.png" title="iPad"><h3 id="iPad-Air"><a href="#iPad-Air" class="headerlink" title="iPad Air"></a>iPad Air</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadAir.png" title="iPad Air"><h3 id="iPad-Pro"><a href="#iPad-Pro" class="headerlink" title="iPad Pro"></a>iPad Pro</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadPro.png" title="iPad Pro"><h3 id="iPad-Mini"><a href="#iPad-Mini" class="headerlink" title="iPad Mini"></a>iPad Mini</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadMini.png" title="iPad Mini"><h3 id="iTouch"><a href="#iTouch" class="headerlink" title="iTouch"></a>iTouch</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iTouch.png" title="iTouch"><h3 id="判断设备类型"><a href="#判断设备类型" class="headerlink" title="判断设备类型"></a>判断设备类型</h3><p>#import &lt;sys/utsname.h&gt;</p><pre><code>+ (NSString *)deviceType{struct utsname systemInfo;uname(&amp;systemInfo);NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];//------------------------------iPhone---------------------------if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;if ([platform isEqualToString:@&quot;iPhone3,1&quot;] ||    [platform isEqualToString:@&quot;iPhone3,2&quot;] ||    [platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([platform isEqualToString:@&quot;iPhone5,1&quot;] ||    [platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;if ([platform isEqualToString:@&quot;iPhone5,3&quot;] ||    [platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;if ([platform isEqualToString:@&quot;iPhone6,1&quot;] ||    [platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;if ([platform isEqualToString:@&quot;iPhone9,1&quot;] ||    [platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7&quot;;if ([platform isEqualToString:@&quot;iPhone9,2&quot;] ||    [platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,1&quot;] ||    [platform isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;iPhone 8&quot;;if ([platform isEqualToString:@&quot;iPhone10,2&quot;] ||    [platform isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;iPhone 8 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,3&quot;] ||    [platform isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;iPhone X&quot;;if ([platform isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([platform isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([platform isEqualToString:@&quot;iPhone11,4&quot;] ||    [platform isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;//------------------------------iPad--------------------------if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([platform isEqualToString:@&quot;iPad2,1&quot;] ||    [platform isEqualToString:@&quot;iPad2,2&quot;] ||    [platform isEqualToString:@&quot;iPad2,3&quot;] ||    [platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([platform isEqualToString:@&quot;iPad3,1&quot;] ||    [platform isEqualToString:@&quot;iPad3,2&quot;] ||    [platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([platform isEqualToString:@&quot;iPad3,4&quot;] ||    [platform isEqualToString:@&quot;iPad3,5&quot;] ||    [platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;if ([platform isEqualToString:@&quot;iPad4,1&quot;] ||    [platform isEqualToString:@&quot;iPad4,2&quot;] ||    [platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;if ([platform isEqualToString:@&quot;iPad5,3&quot;] ||    [platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([platform isEqualToString:@&quot;iPad6,3&quot;] ||    [platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,7&quot;] ||    [platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,11&quot;] ||    [platform isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5&quot;;if ([platform isEqualToString:@&quot;iPad7,1&quot;] ||    [platform isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9-inch 2&quot;;if ([platform isEqualToString:@&quot;iPad7,3&quot;] ||    [platform isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5-inch&quot;;//------------------------------iPad Mini-----------------------if ([platform isEqualToString:@&quot;iPad2,5&quot;] ||    [platform isEqualToString:@&quot;iPad2,6&quot;] ||    [platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad mini&quot;;if ([platform isEqualToString:@&quot;iPad4,4&quot;] ||    [platform isEqualToString:@&quot;iPad4,5&quot;] ||    [platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad mini 2&quot;;if ([platform isEqualToString:@&quot;iPad4,7&quot;] ||    [platform isEqualToString:@&quot;iPad4,8&quot;] ||    [platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad mini 3&quot;;if ([platform isEqualToString:@&quot;iPad5,1&quot;] ||    [platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad mini 4&quot;;//------------------------------iTouch------------------------if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iTouch&quot;;if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iTouch2&quot;;if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iTouch3&quot;;if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iTouch4&quot;;if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iTouch5&quot;;if ([platform isEqualToString:@&quot;iPod7,1&quot;]) return @&quot;iTouch6&quot;;//------------------------------Samulitor-------------------------------------if ([platform isEqualToString:@&quot;i386&quot;] ||     [platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;return @&quot;Unknown&quot;;</code></pre><p>}</p><p>btw：所有设备型号官网地址： <a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Models</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iPhone和iPad分辨率&quot;&gt;&lt;a href=&quot;#iPhone和iPad分辨率&quot; class=&quot;headerlink&quot; title=&quot;iPhone和iPad分辨率&quot;&gt;&lt;/a&gt;iPhone和iPad分辨率&lt;/h3&gt;&lt;img src=&quot;/2019/08/22/oc-
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>GOROOT,GOPATH,GOBIN,project目录</title>
    <link href="https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/"/>
    <id>https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/</id>
    <published>2018-09-12T06:03:28.000Z</published>
    <updated>2019-09-12T06:50:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>我们接下来一个一个来看关于Go语言中的三个目录的详细解释<br>先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)</p><pre><code>wangqiandeMacBook-Pro:~ wangqian$ go envGOARCH=&quot;amd64&quot;GOBIN=&quot;/Users/wangqian/Desktop/Golang_Study/bin&quot;GOCACHE=&quot;/Users/wangqian/Library/Caches/go-build&quot;GOEXE=&quot;&quot;GOFLAGS=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;darwin&quot;GOOS=&quot;darwin&quot;GOPATH=&quot;/Users/wangqian/Desktop/Golang_Study&quot;GOPROXY=&quot;&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/local/go&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;clang&quot;CXX=&quot;clang++&quot;CGO_ENABLED=&quot;1&quot;GOMOD=&quot;&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/zm/zrfg_g0x7f970pp27h3whjd00000gn/T/go-build047476467=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</code></pre><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>其实就是golang 的安装路径<br>当你安装好golang之后其实这个就已经有了,Mac环境下默认为/usr/local/go</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>go命令依赖的一个重要环境变量：$GOPATH</p><p>其实可以把这个目录理解为工作目录，我个人定义的目录是：<br>GOPATH=”/Users/wangqian/Desktop/Golang_Study”<br>当然这个目录是需要添加到环境变量中的</p><p>其中Golang_Study文件下包括</p><pre><code>-- bin 箱子、容器，golang编译可执行文件存放路径-- src 标准要求代码（Standard Requirement Code）源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令-- pkg package包装 golang编译包时，生成的.a文件存放路径</code></pre><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p>首先先看一下我的目录结构</p><img src="/2018/09/12/GolangBasis-day02/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们接下来一个一个来看关于Go语言中的三个目录的详细解释&lt;br&gt;先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wangqiandeMacBook-Pro:~ wangqian$ go env
GOARCH=&amp;
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>

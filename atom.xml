<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wq&#39;s blogs</title>
  
  <subtitle>王乾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wangqian.ltd/"/>
  <updated>2019-08-28T06:18:27.787Z</updated>
  <id>https://www.wangqian.ltd/</id>
  
  <author>
    <name>王乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo无法显示本地图片</title>
    <link href="https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/"/>
    <id>https://www.wangqian.ltd/2019/08/28/hexoDisplayImage/</id>
    <published>2019-08-28T05:46:56.000Z</published>
    <updated>2019-08-28T06:18:27.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插件安装与配置"><a href="#1、插件安装与配置" class="headerlink" title="1、插件安装与配置"></a>1、插件安装与配置</h3><p>首先我们需要安装一个图片转化的插件，这个插件的名字叫 <font color="#000000">hexo-asset-image</font></p><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>但是这个插件的内容需要修改【不然可能会出Bug】<br>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre><code>&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data){  var config = hexo.config;  if(config.post_asset_folder){    var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)   var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;else   var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;link = link.substring(beginPos, endPos);var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;];for(var i = 0; i &lt; toprocess.length; i++){  var key = toprocess[i];  var $ = cheerio.load(data[key], {    ignoreWhitespace: false,    xmlMode: false,    lowerCaseTags: false,    decodeEntities: false  });  $(&apos;img&apos;).each(function(){    if ($(this).attr(&apos;src&apos;)){        // For windows style path, we replace &apos;\&apos; to &apos;/&apos;.        var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;);        if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;           !/^\s*\//.test(src)) {          // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed.          // In addition, to support multi-level local directory.          var linkArray = link.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos;;          });          var srcArray = src.split(&apos;/&apos;).filter(function(elem){            return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;;          });          if(srcArray.length &gt; 1)            srcArray.shift();          src = srcArray.join(&apos;/&apos;);          $(this).attr(&apos;src&apos;, config.root + link + src);          console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);        }    }else{        console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);        console.info&amp;&amp;console.info($(this));    }  });  data[key] = $.html();}  }});</code></pre><p>最后打开_config.yml文件，修改下述内容</p><pre><code>post_asset_folder: true</code></pre><h3 id="2、相对路径引用的标签插件"><a href="#2、相对路径引用的标签插件" class="headerlink" title="2、相对路径引用的标签插件"></a>2、相对路径引用的标签插件</h3><p>存档页和主页不能使用和文章内容中的常规语法来引用图片。<br>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><pre><code>{% asset_img example.jpg This is an example image %}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、插件安装与配置&quot;&gt;&lt;a href=&quot;#1、插件安装与配置&quot; class=&quot;headerlink&quot; title=&quot;1、插件安装与配置&quot;&gt;&lt;/a&gt;1、插件安装与配置&lt;/h3&gt;&lt;p&gt;首先我们需要安装一个图片转化的插件，这个插件的名字叫 &lt;font color=&quot;#0
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="HEXO" scheme="https://www.wangqian.ltd/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>iPhone和iPad分辨率</title>
    <link href="https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/"/>
    <id>https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/</id>
    <published>2019-08-22T08:02:28.000Z</published>
    <updated>2019-08-23T05:13:31.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iPhone和iPad分辨率"><a href="#iPhone和iPad分辨率" class="headerlink" title="iPhone和iPad分辨率"></a>iPhone和iPad分辨率</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/1.png" title="分辨率"><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPhone.png" title="iPhone"><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPad.png" title="iPad"><h3 id="iPad-Air"><a href="#iPad-Air" class="headerlink" title="iPad Air"></a>iPad Air</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadAir.png" title="iPad Air"><h3 id="iPad-Pro"><a href="#iPad-Pro" class="headerlink" title="iPad Pro"></a>iPad Pro</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadPro.png" title="iPad Pro"><h3 id="iPad-Mini"><a href="#iPad-Mini" class="headerlink" title="iPad Mini"></a>iPad Mini</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadMini.png" title="iPad Mini"><h3 id="iTouch"><a href="#iTouch" class="headerlink" title="iTouch"></a>iTouch</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iTouch.png" title="iTouch"><h3 id="判断设备类型"><a href="#判断设备类型" class="headerlink" title="判断设备类型"></a>判断设备类型</h3><p>#import &lt;sys/utsname.h&gt;</p><pre><code>+ (NSString *)deviceType{struct utsname systemInfo;uname(&amp;systemInfo);NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];//------------------------------iPhone---------------------------if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;if ([platform isEqualToString:@&quot;iPhone3,1&quot;] ||    [platform isEqualToString:@&quot;iPhone3,2&quot;] ||    [platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([platform isEqualToString:@&quot;iPhone5,1&quot;] ||    [platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;if ([platform isEqualToString:@&quot;iPhone5,3&quot;] ||    [platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;if ([platform isEqualToString:@&quot;iPhone6,1&quot;] ||    [platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;if ([platform isEqualToString:@&quot;iPhone9,1&quot;] ||    [platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7&quot;;if ([platform isEqualToString:@&quot;iPhone9,2&quot;] ||    [platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,1&quot;] ||    [platform isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;iPhone 8&quot;;if ([platform isEqualToString:@&quot;iPhone10,2&quot;] ||    [platform isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;iPhone 8 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,3&quot;] ||    [platform isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;iPhone X&quot;;if ([platform isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([platform isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([platform isEqualToString:@&quot;iPhone11,4&quot;] ||    [platform isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;//------------------------------iPad--------------------------if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([platform isEqualToString:@&quot;iPad2,1&quot;] ||    [platform isEqualToString:@&quot;iPad2,2&quot;] ||    [platform isEqualToString:@&quot;iPad2,3&quot;] ||    [platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([platform isEqualToString:@&quot;iPad3,1&quot;] ||    [platform isEqualToString:@&quot;iPad3,2&quot;] ||    [platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([platform isEqualToString:@&quot;iPad3,4&quot;] ||    [platform isEqualToString:@&quot;iPad3,5&quot;] ||    [platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;if ([platform isEqualToString:@&quot;iPad4,1&quot;] ||    [platform isEqualToString:@&quot;iPad4,2&quot;] ||    [platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;if ([platform isEqualToString:@&quot;iPad5,3&quot;] ||    [platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([platform isEqualToString:@&quot;iPad6,3&quot;] ||    [platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,7&quot;] ||    [platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,11&quot;] ||    [platform isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5&quot;;if ([platform isEqualToString:@&quot;iPad7,1&quot;] ||    [platform isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9-inch 2&quot;;if ([platform isEqualToString:@&quot;iPad7,3&quot;] ||    [platform isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5-inch&quot;;//------------------------------iPad Mini-----------------------if ([platform isEqualToString:@&quot;iPad2,5&quot;] ||    [platform isEqualToString:@&quot;iPad2,6&quot;] ||    [platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad mini&quot;;if ([platform isEqualToString:@&quot;iPad4,4&quot;] ||    [platform isEqualToString:@&quot;iPad4,5&quot;] ||    [platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad mini 2&quot;;if ([platform isEqualToString:@&quot;iPad4,7&quot;] ||    [platform isEqualToString:@&quot;iPad4,8&quot;] ||    [platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad mini 3&quot;;if ([platform isEqualToString:@&quot;iPad5,1&quot;] ||    [platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad mini 4&quot;;//------------------------------iTouch------------------------if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iTouch&quot;;if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iTouch2&quot;;if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iTouch3&quot;;if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iTouch4&quot;;if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iTouch5&quot;;if ([platform isEqualToString:@&quot;iPod7,1&quot;]) return @&quot;iTouch6&quot;;//------------------------------Samulitor-------------------------------------if ([platform isEqualToString:@&quot;i386&quot;] ||     [platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;return @&quot;Unknown&quot;;</code></pre><p>}</p><p>btw：所有设备型号官网地址： <a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Models</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iPhone和iPad分辨率&quot;&gt;&lt;a href=&quot;#iPhone和iPad分辨率&quot; class=&quot;headerlink&quot; title=&quot;iPhone和iPad分辨率&quot;&gt;&lt;/a&gt;iPhone和iPad分辨率&lt;/h3&gt;&lt;img src=&quot;/2019/08/22/oc-
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>GOROOT,GOPATH,GOBIN,project目录</title>
    <link href="https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/"/>
    <id>https://www.wangqian.ltd/2018/09/12/GolangBasis-day02/</id>
    <published>2018-09-12T06:03:28.000Z</published>
    <updated>2019-09-12T06:50:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>我们接下来一个一个来看关于Go语言中的三个目录的详细解释<br>先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)</p><pre><code>wangqiandeMacBook-Pro:~ wangqian$ go envGOARCH=&quot;amd64&quot;GOBIN=&quot;/Users/wangqian/Desktop/Golang_Study/bin&quot;GOCACHE=&quot;/Users/wangqian/Library/Caches/go-build&quot;GOEXE=&quot;&quot;GOFLAGS=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;darwin&quot;GOOS=&quot;darwin&quot;GOPATH=&quot;/Users/wangqian/Desktop/Golang_Study&quot;GOPROXY=&quot;&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/local/go&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;clang&quot;CXX=&quot;clang++&quot;CGO_ENABLED=&quot;1&quot;GOMOD=&quot;&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/zm/zrfg_g0x7f970pp27h3whjd00000gn/T/go-build047476467=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</code></pre><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>其实就是golang 的安装路径<br>当你安装好golang之后其实这个就已经有了,Mac环境下默认为/usr/local/go</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>go命令依赖的一个重要环境变量：$GOPATH</p><p>其实可以把这个目录理解为工作目录，我个人定义的目录是：<br>GOPATH=”/Users/wangqian/Desktop/Golang_Study”<br>当然这个目录是需要添加到环境变量中的</p><p>其中Golang_Study文件下包括</p><pre><code>-- bin 箱子、容器，golang编译可执行文件存放路径-- src 标准要求代码（Standard Requirement Code）源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令-- pkg package包装 golang编译包时，生成的.a文件存放路径</code></pre><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p>首先先看一下我的目录结构</p><img src="/2018/09/12/GolangBasis-day02/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们接下来一个一个来看关于Go语言中的三个目录的详细解释&lt;br&gt;先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wangqiandeMacBook-Pro:~ wangqian$ go env
GOARCH=&amp;
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac下配置.bash_profile（环境变量）</title>
    <link href="https://www.wangqian.ltd/2018/09/10/Config-bash-profile/"/>
    <id>https://www.wangqian.ltd/2018/09/10/Config-bash-profile/</id>
    <published>2018-09-10T06:54:20.000Z</published>
    <updated>2019-09-12T07:01:27.411Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习Golang,在调试程序时报错，然后为了解决错误不小心改了.bash_profile这个文件，也就是配置环境变量，结果导致终端很多基本命令都不能使用，在网上找到一些解决办法，亲测有效。</p><p>1、在命令行中输入：</p><pre><code>export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</code></pre><p>这样可以保证命令行命令暂时可以使用。命令执行完之后先不要关闭终端。<br>如果你的命令行命令可以使用，请直接跳到第2步。</p><p>2、进入当前用户的home目录：</p><pre><code>cd ~/</code></pre><p>3、创建.bash_profile文件：</p><pre><code>touch .bash_profile</code></pre><p>4、 打开.bash_profile并编辑：</p><pre><code>open .bash_profile</code></pre><p>5、这样就打开了一个记事本，会显示你之前配置过的path，修改记事本，强烈建议先备份下，然后根据自己需要配置。</p><pre><code>JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATHexport GOPATH=/Users/wangqian/Desktop/Golang_Studyexport GOROOT=/usr/local/goexport GOBIN=$GOPATH/binexport PATH=$PATH:$GOBIN</code></pre><p>上面是我配置的Java环境和golang环境</p><p>6、command+s保存关闭文件</p><p>7、使修改后的配置生效命令：</p><pre><code>source .bash_profile</code></pre><p>8、验证环境变量是否配置成功</p><p>如果是java,在终端输入以下命令</p><pre><code>java -version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开始学习Golang,在调试程序时报错，然后为了解决错误不小心改了.bash_profile这个文件，也就是配置环境变量，结果导致终端很多基本命令都不能使用，在网上找到一些解决办法，亲测有效。&lt;/p&gt;
&lt;p&gt;1、在命令行中输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expor
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac环境下安装、配置golang</title>
    <link href="https://www.wangqian.ltd/2018/09/02/GolangBasis-day01/"/>
    <id>https://www.wangqian.ltd/2018/09/02/GolangBasis-day01/</id>
    <published>2018-09-02T03:20:42.000Z</published>
    <updated>2019-09-16T06:25:45.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h3><p>1、国内镜像下载地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a><br>2、终端中输入go ，若出现下图即安装成功。</p><pre><code>Go is a tool for managing Go source code.Usage:go &lt;command&gt; [arguments]The commands are:bug         start a bug reportbuild       compile packages and dependenciesclean       remove object files and cached filesdoc         show documentation for package or symbolenv         print Go environment informationfix         update packages to use new APIsfmt         gofmt (reformat) package sourcesgenerate    generate Go files by processing sourceget         download and install packages and dependenciesinstall     compile and install packages and dependencieslist        list packages or modulesmod         module maintenancerun         compile and run Go programtest        test packagestool        run specified go toolversion     print Go versionvet         report likely mistakes in packagesUse &quot;go help &lt;command&gt;&quot; for more information about a command.Additional help topics:buildmode   build modesc           calling between Go and Ccache       build and test cachingenvironment environment variablesfiletype    file typesgo.mod      the go.mod filegopath      GOPATH environment variablegopath-get  legacy GOPATH go getgoproxy     module proxy protocolimportpath  import path syntaxmodules     modules, module versions, and moremodule-get  module-aware go getpackages    package lists and patternstestflag    testing flagstestfunc    testing functionsUse &quot;go help &lt;topic&gt;&quot; for more information about that topic.</code></pre><p>3、开发环境构建：通过go version查看版本，在1.8版本前必须设置这个环境变量。1.8版本后（含1.8）如果没有设置使用默认值</p><pre><code>在 Unix 上默认为 $HOME/go 在 Windows 上默认为 %USERPROFILE%/go 在 Mac 上 GOPATH 可以通过修改 ~/.bash_profile 来设置</code></pre><h3 id="2、测试是否安装成功"><a href="#2、测试是否安装成功" class="headerlink" title="2、测试是否安装成功"></a>2、测试是否安装成功</h3><p>新建源码文件hello.go</p><pre><code>cd /Users/wangqian/Desktop/Golang_Study/src  //打开源文件存放的位置vim hello.go   // 编辑hello.go文件</code></pre><p>编码hello.go文件：</p><pre><code>package mainimport &quot;fmt&quot;func main(){fmt.Printf(&quot;hello world\n&quot;)}</code></pre><p>退出保存后直接运行</p><pre><code>go run hello.gowangqiandeMacBook-Pro:src wangqian$ go run hello.gohello world</code></pre><p>现在我们把源文件编译成二进制文件，并且运行当前二进制文件</p><pre><code>go build -ldflags &quot;-s -w&quot; -o hi.outwangqiandeMacBook-Pro:src wangqian$ go build -ldflags &quot;-s -w&quot; -o hi.outwangqiandeMacBook-Pro:src wangqian$ ./hi.outhello world</code></pre><p>这样在当前文件夹中就会存在一个源文件，一个编译文件<br>    <img src="/2018/09/02/GolangBasis-day01/1.png"></p><h3 id="3、go常用命令介绍"><a href="#3、go常用命令介绍" class="headerlink" title="3、go常用命令介绍"></a>3、go常用命令介绍</h3><p>go run 路径需要完整的路径到src<br>wangqiandeMacBook-Pro:Golang_Study wangqian$ go run src/day_01/hello_world.go</p><p>hello world</p><p>wangqiandeMacBook-Pro:Golang_Study wangqian$ go run day_01/hello_world.go</p><p>stat day_01/hello_world.go: no such file or directory</p><p>go build 编译的时候制定固定的包就行了，不需要带上src<br>go build day_01  go build 是在当前文件路径生成可执行文件，<br>go build -o bin/hello2 day_01  指定在bin路径下生成名称hello2的可执行文件</p><p>go install day_01  生成可执行文件在bin目录下<br>前提是go环境bin路径修改过 GOBIN=”/Users/wangqian/Desktop/Golang_Study/bin”</p><p>go fmt day_01  格式化代码  直接包名路径就行</p><p>在VSCode中目录结构如下图所示：</p><img src="/2018/09/02/GolangBasis-day01/2.png"><h3 id="4、设置GOPATH环境变量"><a href="#4、设置GOPATH环境变量" class="headerlink" title="4、设置GOPATH环境变量"></a>4、设置GOPATH环境变量</h3><p>开始写 go 项目代码之前，需要我们先配置好环境变量。编辑 ~/.bash_profile（在终端中运行 vi ~/.bash_profile 即可）来添加下面这行代码（如果你找不到 .bash_profile，那自己创建一个就可以了）</p><pre><code>export GOPATH=$HOME/go</code></pre><p>保存然后退出你的编辑器。然后在终端中运行下面命令</p><pre><code>source ~/.bash_profile</code></pre><p>提示：$HOME是每个电脑下的用户主目录，每个电脑可能不同，可以在终端运行 echo $HOME 获取<br>GOROOT 默认是在 /usr/local/go，如果没有，可以在 bash_profile 文件中设置。<br>export GOROOT=/usr/local/go<br>然后保存并退出编辑器，运行 source ~/.bash_profile 命令即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、下载&quot;&gt;&lt;a href=&quot;#1、下载&quot; class=&quot;headerlink&quot; title=&quot;1、下载&quot;&gt;&lt;/a&gt;1、下载&lt;/h3&gt;&lt;p&gt;1、国内镜像下载地址：&lt;a href=&quot;https://golang.google.cn/dl/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang基础" scheme="https://www.wangqian.ltd/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Desktop 链接 码云、GitLab使用方法</title>
    <link href="https://www.wangqian.ltd/2018/09/01/GitHub-Desktop/"/>
    <id>https://www.wangqian.ltd/2018/09/01/GitHub-Desktop/</id>
    <published>2018-09-01T07:18:05.000Z</published>
    <updated>2019-09-01T07:32:17.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、添加SSH私钥并连接"><a href="#1、添加SSH私钥并连接" class="headerlink" title="1、添加SSH私钥并连接"></a>1、添加SSH私钥并连接</h3><pre><code>1、ssh-add /Users/wangqian/id_rsa     /Users/wangqian/id_rsa 为私钥的地址2、ssh -T git@gitlab.ttsing.com当出现 Welcome to GitLab, wq! 表示连接成功</code></pre><h3 id="2、如何从码云、GitLab导入到GitHubDeskTop桌面工具"><a href="#2、如何从码云、GitLab导入到GitHubDeskTop桌面工具" class="headerlink" title="2、如何从码云、GitLab导入到GitHubDeskTop桌面工具"></a>2、如何从码云、GitLab导入到GitHubDeskTop桌面工具</h3><p>1、先用命令行切换到本地的目录。<br>2、使用git clone 码云GIT地址 命令将项目克隆到本地。<br>3、在GitHub Desktop上添加(Add)本地项目(local path)。<br>4、在GitHub Desktop上尽情地提交、同步吧！</p><h3 id="3、如何将本地的项目上传到码码云、GitLab"><a href="#3、如何将本地的项目上传到码码云、GitLab" class="headerlink" title="3、如何将本地的项目上传到码码云、GitLab"></a>3、如何将本地的项目上传到码码云、GitLab</h3><p>1、选择本地目录，在GitHub Desktop上添加本地项目。<br>2、在码云GIT上新建项目。<br>3、 命令行使用git remote add origin GIT地址 将本地项目与码云GIT项目建立关系。<br>4、先使用命令git pull origin master 同步代码。<br>5、使用命令git push origin master 将本地代码推送到远程项目。<br>6、在GitHub Desktop上尽情地提交、同步吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、添加SSH私钥并连接&quot;&gt;&lt;a href=&quot;#1、添加SSH私钥并连接&quot; class=&quot;headerlink&quot; title=&quot;1、添加SSH私钥并连接&quot;&gt;&lt;/a&gt;1、添加SSH私钥并连接&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、ssh-add /Users/wangq
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="GitHub" scheme="https://www.wangqian.ltd/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://www.wangqian.ltd/2018/08/29/MarkdownGrammar/"/>
    <id>https://www.wangqian.ltd/2018/08/29/MarkdownGrammar/</id>
    <published>2018-08-29T06:05:32.000Z</published>
    <updated>2019-08-29T09:26:10.651Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/1.png"><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h3><p>加粗 - 要加粗的文字左右分别用两个*号包起来</p><p>斜体 - 要倾斜的文字左右分别用一个*号包起来</p><p>斜体加粗 - 要倾斜和加粗的文字左右分别用三个*号包起来</p><p>删除线 - 要加删除线的文字左右分别用两个~~号包起来</p><p>修改字体颜色 - <font color="#FF0000"> 字体改成红色了 </font><br>示例：</p><pre><code>**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~&lt;font color=红色&gt; 字体改成红色了 &lt;/font&gt;</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/2.png"><h3 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h3><p>在需要引用的文字前加&gt;即可。<br>示例：</p><pre><code>&gt;这里是引用的内容&gt;&gt;这里是引用的内容</code></pre><p>效果如下：</p><img src="/2018/08/29/MarkdownGrammar/3.png" title="This is an image"><h3 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h3><p>三个或者三个以上 - 或者 * 都可以<br>示例：</p><pre><code>-------*******</code></pre><h3 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h3><pre><code>![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><h3 id="6、超链接"><a href="#6、超链接" class="headerlink" title="6、超链接"></a>6、超链接</h3><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[百度](http://baidu.com)</code></pre><p>效果如下：</p><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="7、表格"><a href="#7、表格" class="headerlink" title="7、表格"></a>7、表格</h3><p>语法如下：</p><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;h3 id=&quot;1、标题&quot;&gt;&lt;a href=&quot;#1、标题&quot; class=&quot;headerlink&quot; title=&quot;1、标题&quot;&gt;&lt;/a&gt;1、标题&lt;/h3&gt;&lt;p&gt;在想要设
      
    
    </summary>
    
      <category term="工具" scheme="https://www.wangqian.ltd/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://www.wangqian.ltd/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>iOS单例模式，你真的写对了吗？</title>
    <link href="https://www.wangqian.ltd/2017/08/23/oc-develop-singleton/"/>
    <id>https://www.wangqian.ltd/2017/08/23/oc-develop-singleton/</id>
    <published>2017-08-23T11:00:17.000Z</published>
    <updated>2019-08-27T06:56:08.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例类的生命周期"><a href="#单例类的生命周期" class="headerlink" title="单例类的生命周期"></a>单例类的生命周期</h3><p>单例实例在存储器的中位置</p><p>请看下面的表格展示了程序中中不同的变量在手机存储器中的存储位置；</p><img src="/2017/08/23/oc-develop-singleton/memoryposition.png"><p>在程序中，一个单例类在程序中只能初始化一次，为了保证在使用中始终都是存在的，所以单例是在存储器的全局区域，在编译时分配内存，只要程序还在运行就会一直占用内存，在APP结束后由系统释放这部分内存内存。</p><p>单例模式很常见，但是，能真正把单利模式写对的却很少。在iOS中，一般我们都是用官方推荐的写法来写单例：</p><pre><code>+ (instancetype)sharedInstance {    static WQSQLiteManager *instance = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        instance = [[WQSQLiteManager alloc] init];    });    return instance;}</code></pre><p>这也是我们单例模式的标准写法。 在使用时，我们只需要</p><pre><code>WQSQLiteManager *manager = [WQSQLiteManager sharedInstance];</code></pre><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>可是，在多人开发中，并不能保证所有人都会使用 sharedInstance 方法来创建对象；而一旦有人用 alloc，new 等来创建对象，这就不是单例了。例如：</p><pre><code>WQSQLiteManager *a = [WQSQLiteManager sharedInstance];WQSQLiteManager *b = [[WQSQLiteManager alloc] init];WQSQLiteManager *c = [WQSQLiteManager new];</code></pre><p>让我们来打印 a、b、c内存地址：</p><pre><code>a:&lt;WQSQLiteManager: 0x600001f1fdf0&gt;b:&lt;WQSQLiteManager: 0x600001f1fe00&gt;c:&lt;WQSQLiteManager: 0x600001f1fe10&gt;</code></pre><p>可以看出，<font color="#FF0000"> a、b、c 不是同一个对象，而所谓单例，就是不管我用何种方法创建对象，都必须是同一个。</font>所以，单例模式，绝不是一个 sharedInstance 就够了。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>那么如何避免这种问题呢？我们知道：在对象创建的时候，alloc、new都会调用到 allocWithZone: 方法；使用拷贝创建对象时，会调用 copyWithZone: 、mutableCopyWithZone:方法；那么，重写这些方法，就可以让创建的对象唯一。</p><pre><code>+ (instancetype)sharedInstance {    static WQSQLiteManager *instance = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{    //   instance = [[WQSQLiteManager alloc] init];   instance = [[super allocWithZone:nil] init];});    return instance;}+ (instancetype)allocWithZone:(struct _NSZone *)zone {    return [WQSQLiteManager sharedInstance];}- (instancetype)copyWithZone:(NSZone *)zone {    return [WQSQLiteManager sharedInstance];}- (instancetype)mutableCopyWithZone:(NSZone *)zone     {        return [WQSQLiteManager sharedInstance];}</code></pre><p>再运行，看一看a、b、c：</p><pre><code>a:&lt;WQSQLiteManager: 0x60000331d690&gt;a:&lt;WQSQLiteManager: 0x60000331d690&gt;a:&lt;WQSQLiteManager: 0x60000331d690&gt;</code></pre><p>初始化一个对象的时候，[[Class alloc] init]，其实是做了两件事。<br>alloc 给对象分配内存空间，init是对对象的初始化，包括设置成员变量初值这些工作。<br>而给对象分配空间，除了alloc方法之外，还有另一个方法： allocWithZone.<br>使用alloc方法初始化一个类的实例的时候，默认是调用了allocWithZone的方法</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>还有一种方法，就是直接禁用掉 alloc、new 、copy等方法：</p><pre><code>// 告诉编译器该方法不可用，如果强行调用编译器会提示错误+ (instancetype)alloc UNAVAILABLE_ATTRIBUTE;+ (instancetype)new __attribute__((unavailable(&quot;replace with &apos;sharedInstance&apos;&quot;)));- (instancetype)copy __attribute__((unavailable(&quot;replace with &apos;sharedInstance&apos;&quot;)));- (instancetype)mutableCopy __attribute__((unavailable(&quot;replace with &apos;sharedInstance&apos;&quot;)));+ (instancetype)sharedInstance {static WQSQLiteManager *instance = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{    //instance = [[WQSQLiteManager alloc] init];    instance = [[super allocWithZone:nil] init];});return instance;}</code></pre><p>那么，在调用这些方法的时候就会报错，</p><img src="/2017/08/23/oc-develop-singleton/singleErroe.png"><p>以此达到单例模式的要求，始终只有一个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单例类的生命周期&quot;&gt;&lt;a href=&quot;#单例类的生命周期&quot; class=&quot;headerlink&quot; title=&quot;单例类的生命周期&quot;&gt;&lt;/a&gt;单例类的生命周期&lt;/h3&gt;&lt;p&gt;单例实例在存储器的中位置&lt;/p&gt;
&lt;p&gt;请看下面的表格展示了程序中中不同的变量在手机存储器中
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中的各种遍历方式</title>
    <link href="https://www.wangqian.ltd/2017/08/21/oc-develop-cycle/"/>
    <id>https://www.wangqian.ltd/2017/08/21/oc-develop-cycle/</id>
    <published>2017-08-21T07:58:16.000Z</published>
    <updated>2019-08-21T08:58:24.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、使用for循环"><a href="#1、使用for循环" class="headerlink" title="1、使用for循环"></a>1、使用for循环</h3><p>要遍历字典、数组或者是集合，for循环是最简单也用的比较多的方法，示例如下：　</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (int i = 0; i &lt; array.count; i ++) {    NSString *obj = array[i];    NSLog(@&quot;%@&quot;,obj);}//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};NSArray *dictKeysArray = [dictM allKeys];for (int i = 0; i&lt;dictKeysArray.count; i++) {    NSString *key = dictKeysArray[i];    NSString *obj = [dictM objectForKey:key];    NSLog(@&quot;%@:%@&quot;,key,obj);}// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];for (NSInteger index = 0; index &lt; set.allObjects.count; index ++) {    NSString *obj = set.allObjects[index];    NSLog(@&quot;%@&quot;,obj);}// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (NSInteger index = array2.count - 1; index &gt;= 0; index --) {    NSLog(@&quot;%@&quot;,array2[index]);}</code></pre><p>优点：简单</p><p>缺点：由于字典和集合内部是无序的，导致我们在遍历字典和集合的时候需要借助一个新的“数组”作为中介来处理，多出了一部分开销。</p><h3 id="2、使用for…in循环"><a href="#2、使用for…in循环" class="headerlink" title="2、使用for…in循环"></a>2、使用for…in循环</h3><p>在Objective-C 2.0 中增加了for …In 形式的快速遍历。此种遍历方式语法简洁，速度飞快。示例如下：</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (id obj in array) {    NSLog(@&quot;%@&quot;,obj);}//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};for (id obj in dictM) {    NSLog(@&quot;%@&quot;,dictM[obj]);}// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];for (id obj in set) {    NSLog(@&quot;%@&quot;,obj);}// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (id obj in [array2 reverseObjectEnumerator]) {    NSLog(@&quot;%@&quot;,obj);}</code></pre><p>优点：1）语法简洁；2）效率最高；</p><p>缺点：无法获得当前遍历操作所针对的下标。</p><h3 id="3、使用NSEnumerator遍历"><a href="#3、使用NSEnumerator遍历" class="headerlink" title="3、使用NSEnumerator遍历"></a>3、使用NSEnumerator遍历</h3><p>NSEnumerator的使用和基本的for循环类似，不过代码量要大一些。示例如下：</p><pre><code>// 数组NSArray *arrayM = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];NSEnumerator *arrayEnumerator = [arrayM objectEnumerator];NSString *obj;while ((obj = [arrayEnumerator nextObject]) != nil) {    NSLog(@&quot;%@&quot;,obj);}// 字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};NSEnumerator *dictEnumerator = [dictM keyEnumerator];NSString *key;while ((key = [dictEnumerator nextObject]) != nil) {    NSString *obj = dictM[key];    NSLog(@&quot;%@&quot;,obj);}// 集合（无序、不能重复 其他和Array一样）NSSet * setM = [[NSSet alloc] initWithObjects:@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,@&quot;four&quot;, nil];NSEnumerator *setEnumerator = [setM objectEnumerator];NSString *setObj;while ((setObj = [setEnumerator nextObject]) != nil) {    NSLog(@&quot;%@&quot;,setObj);}// 反向遍历（以数组为例子）NSArray *arrayM2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];NSEnumerator *arrayEnumerator2 = [arrayM2 reverseObjectEnumerator];NSString *obj2;while ((obj2 = [arrayEnumerator2 nextObject]) != nil) {    NSLog(@&quot;%@&quot;,obj2);}</code></pre><p>优点：对于不同的数据类型，遍历的语法相似；内部可以简单的通过reverseObjectEnumerator设置进行反向遍历。</p><p>缺点：代码量稍大。</p><h3 id="4、基于Block的遍历方式"><a href="#4、基于Block的遍历方式" class="headerlink" title="4、基于Block的遍历方式"></a>4、基于Block的遍历方式</h3><p>基于Block的方式来进行遍历是最新引入的方法。它提供了遍历数组|字典等类型数据的最佳实践。示例如下：</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSLog(@&quot;%lu--%@&quot;,(unsigned long)idx,obj);}];//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};[dictM enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {    NSLog(@&quot;%@:%@&quot;,key,obj);}];// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];[set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {    NSLog(@&quot;%@&quot;,obj);}];// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];[array2 enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSLog(@&quot;%zd--%@&quot;,idx,obj);}];</code></pre><p>优点：1）遍历时可以直接从block中获得需要的所有信息，包括下标、值等。特别相对于字典而言，不需要做多余的编码即可同时获得key和value的值。</p><p>　　　2）能够直接修改block中key或者obj的类型为真实类型，可以省去类型转换的工作。</p><p>　　　3）可以通过NSEnumerationConcurrent枚举值开启并发迭代功能。</p><p>说明：基于Block的遍历方式在实现反向遍历的时候也非常简单，使用enumerateObjectsWithOptions方法，传递NSEnumerationReverse作为参数即可，在处理遍历操作的时候推荐基于Block的遍历方式。</p><h3 id="5、使GCD中的dispatch-apply函数"><a href="#5、使GCD中的dispatch-apply函数" class="headerlink" title="5、使GCD中的dispatch_apply函数"></a>5、使GCD中的dispatch_apply函数</h3><p>使用GCD中的dispatch_apply函数也能实现字典、数组等的遍历，该函数比较适合处理耗时较长、迭代次数较多的情况。示例如下：</p><pre><code>NSArray *array3 = @[@&quot;10&quot;,@&quot;11&quot;,@&quot;12&quot;,@&quot;13&quot;,@&quot;14&quot;];dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(array3.count, queue, ^(size_t index) {    NSLog(@&quot;%@--%@&quot;,array3[index],[NSThread currentThread]);});</code></pre><p>优点：开启多条线程并发处理遍历任务，执行效率高。</p><p>缺点：1）对于字典和集合的处理需借助数组；2）无法实现反向遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、使用for循环&quot;&gt;&lt;a href=&quot;#1、使用for循环&quot; class=&quot;headerlink&quot; title=&quot;1、使用for循环&quot;&gt;&lt;/a&gt;1、使用for循环&lt;/h3&gt;&lt;p&gt;要遍历字典、数组或者是集合，for循环是最简单也用的比较多的方法，示例如下：　&lt;/p
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>

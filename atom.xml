<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wq&#39;s blogs</title>
  
  <subtitle>王乾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wangqian.ltd/"/>
  <updated>2019-08-23T05:13:31.855Z</updated>
  <id>https://www.wangqian.ltd/</id>
  
  <author>
    <name>王乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iPhone和iPad分辨率</title>
    <link href="https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/"/>
    <id>https://www.wangqian.ltd/2019/08/22/oc-develop-deviceMeasurement/</id>
    <published>2019-08-22T08:02:28.000Z</published>
    <updated>2019-08-23T05:13:31.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iPhone和iPad分辨率"><a href="#iPhone和iPad分辨率" class="headerlink" title="iPhone和iPad分辨率"></a>iPhone和iPad分辨率</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/1.png" title="分辨率"><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPhone.png" title="iPhone"><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPad.png" title="iPad"><h3 id="iPad-Air"><a href="#iPad-Air" class="headerlink" title="iPad Air"></a>iPad Air</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadAir.png" title="iPad Air"><h3 id="iPad-Pro"><a href="#iPad-Pro" class="headerlink" title="iPad Pro"></a>iPad Pro</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadPro.png" title="iPad Pro"><h3 id="iPad-Mini"><a href="#iPad-Mini" class="headerlink" title="iPad Mini"></a>iPad Mini</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iPadMini.png" title="iPad Mini"><h3 id="iTouch"><a href="#iTouch" class="headerlink" title="iTouch"></a>iTouch</h3><img src="/2019/08/22/oc-develop-deviceMeasurement/iTouch.png" title="iTouch"><h3 id="判断设备类型"><a href="#判断设备类型" class="headerlink" title="判断设备类型"></a>判断设备类型</h3><p>#import &lt;sys/utsname.h&gt;</p><pre><code>+ (NSString *)deviceType{struct utsname systemInfo;uname(&amp;systemInfo);NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];//------------------------------iPhone---------------------------if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;if ([platform isEqualToString:@&quot;iPhone3,1&quot;] ||    [platform isEqualToString:@&quot;iPhone3,2&quot;] ||    [platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([platform isEqualToString:@&quot;iPhone5,1&quot;] ||    [platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;if ([platform isEqualToString:@&quot;iPhone5,3&quot;] ||    [platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;if ([platform isEqualToString:@&quot;iPhone6,1&quot;] ||    [platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;if ([platform isEqualToString:@&quot;iPhone9,1&quot;] ||    [platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7&quot;;if ([platform isEqualToString:@&quot;iPhone9,2&quot;] ||    [platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,1&quot;] ||    [platform isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;iPhone 8&quot;;if ([platform isEqualToString:@&quot;iPhone10,2&quot;] ||    [platform isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;iPhone 8 Plus&quot;;if ([platform isEqualToString:@&quot;iPhone10,3&quot;] ||    [platform isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;iPhone X&quot;;if ([platform isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([platform isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([platform isEqualToString:@&quot;iPhone11,4&quot;] ||    [platform isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;//------------------------------iPad--------------------------if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([platform isEqualToString:@&quot;iPad2,1&quot;] ||    [platform isEqualToString:@&quot;iPad2,2&quot;] ||    [platform isEqualToString:@&quot;iPad2,3&quot;] ||    [platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([platform isEqualToString:@&quot;iPad3,1&quot;] ||    [platform isEqualToString:@&quot;iPad3,2&quot;] ||    [platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([platform isEqualToString:@&quot;iPad3,4&quot;] ||    [platform isEqualToString:@&quot;iPad3,5&quot;] ||    [platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;if ([platform isEqualToString:@&quot;iPad4,1&quot;] ||    [platform isEqualToString:@&quot;iPad4,2&quot;] ||    [platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;if ([platform isEqualToString:@&quot;iPad5,3&quot;] ||    [platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([platform isEqualToString:@&quot;iPad6,3&quot;] ||    [platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,7&quot;] ||    [platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9-inch&quot;;if ([platform isEqualToString:@&quot;iPad6,11&quot;] ||    [platform isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5&quot;;if ([platform isEqualToString:@&quot;iPad7,1&quot;] ||    [platform isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9-inch 2&quot;;if ([platform isEqualToString:@&quot;iPad7,3&quot;] ||    [platform isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5-inch&quot;;//------------------------------iPad Mini-----------------------if ([platform isEqualToString:@&quot;iPad2,5&quot;] ||    [platform isEqualToString:@&quot;iPad2,6&quot;] ||    [platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad mini&quot;;if ([platform isEqualToString:@&quot;iPad4,4&quot;] ||    [platform isEqualToString:@&quot;iPad4,5&quot;] ||    [platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad mini 2&quot;;if ([platform isEqualToString:@&quot;iPad4,7&quot;] ||    [platform isEqualToString:@&quot;iPad4,8&quot;] ||    [platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad mini 3&quot;;if ([platform isEqualToString:@&quot;iPad5,1&quot;] ||    [platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad mini 4&quot;;//------------------------------iTouch------------------------if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iTouch&quot;;if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iTouch2&quot;;if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iTouch3&quot;;if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iTouch4&quot;;if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iTouch5&quot;;if ([platform isEqualToString:@&quot;iPod7,1&quot;]) return @&quot;iTouch6&quot;;//------------------------------Samulitor-------------------------------------if ([platform isEqualToString:@&quot;i386&quot;] ||     [platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;return @&quot;Unknown&quot;;</code></pre><p>}</p><p>btw：所有设备型号官网地址： <a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">https://www.theiphonewiki.com/wiki/Models</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iPhone和iPad分辨率&quot;&gt;&lt;a href=&quot;#iPhone和iPad分辨率&quot; class=&quot;headerlink&quot; title=&quot;iPhone和iPad分辨率&quot;&gt;&lt;/a&gt;iPhone和iPad分辨率&lt;/h3&gt;&lt;img src=&quot;/2019/08/22/oc-
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态</title>
    <link href="https://www.wangqian.ltd/2018/07/30/tcp_code/"/>
    <id>https://www.wangqian.ltd/2018/07/30/tcp_code/</id>
    <published>2018-07-30T04:46:21.000Z</published>
    <updated>2019-08-20T10:09:34.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="建立连接协议（三次握手）"><a href="#建立连接协议（三次握手）" class="headerlink" title="建立连接协议（三次握手）"></a>建立连接协议（三次握手）</h4><a id="more"></a><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。</li><li>服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标志。因此它表示对刚才客户端SYN报文的回应；同时又标志SYN给客户端，询问客户端是否准备好进行数据通讯。</li><li>客户必须再次回应服务段一个ACK报文，这是报文段3。<br><img src="/uploads/tcp_code/1_img.jpg" alt="1"></li></ol><h4 id="连接终止协议（四次释放）"><a href="#连接终止协议（四次释放）" class="headerlink" title="连接终止协议（四次释放）"></a>连接终止协议（四次释放）</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）</li><li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</li><li>服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。</li><li>客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</li></ol><hr><p><strong>TIME_WAIT</strong>：通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间(后有MSL的解释)，进入CLOSED状态。</p><p>下图是以客户端主动关闭连接为例，说明这一过程的。</p><p><img src="/uploads/tcp_code/2_img.jpg" alt="1"></p><p><strong>CLOSE_WAIT</strong>: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p><p><strong>MSL</strong>：就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。</p><p><strong>TIME_WAIT</strong>状态维持时间：TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。</p><p>A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？<br>答：A处于ESTABLISHED状态，B突然重启，A感知不到B的状态，可以通过心跳来探测对方状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;建立连接协议（三次握手）&quot;&gt;&lt;a href=&quot;#建立连接协议（三次握手）&quot; class=&quot;headerlink&quot; title=&quot;建立连接协议（三次握手）&quot;&gt;&lt;/a&gt;建立连接协议（三次握手）&lt;/h4&gt;
    
    </summary>
    
      <category term="网络层" scheme="https://www.wangqian.ltd/categories/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="tcp" scheme="https://www.wangqian.ltd/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中的各种遍历方式</title>
    <link href="https://www.wangqian.ltd/2017/08/21/oc-develop-cycle/"/>
    <id>https://www.wangqian.ltd/2017/08/21/oc-develop-cycle/</id>
    <published>2017-08-21T07:58:16.000Z</published>
    <updated>2019-08-21T08:58:24.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、使用for循环"><a href="#1、使用for循环" class="headerlink" title="1、使用for循环"></a>1、使用for循环</h3><p>要遍历字典、数组或者是集合，for循环是最简单也用的比较多的方法，示例如下：　</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (int i = 0; i &lt; array.count; i ++) {    NSString *obj = array[i];    NSLog(@&quot;%@&quot;,obj);}//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};NSArray *dictKeysArray = [dictM allKeys];for (int i = 0; i&lt;dictKeysArray.count; i++) {    NSString *key = dictKeysArray[i];    NSString *obj = [dictM objectForKey:key];    NSLog(@&quot;%@:%@&quot;,key,obj);}// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];for (NSInteger index = 0; index &lt; set.allObjects.count; index ++) {    NSString *obj = set.allObjects[index];    NSLog(@&quot;%@&quot;,obj);}// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (NSInteger index = array2.count - 1; index &gt;= 0; index --) {    NSLog(@&quot;%@&quot;,array2[index]);}</code></pre><p>优点：简单</p><p>缺点：由于字典和集合内部是无序的，导致我们在遍历字典和集合的时候需要借助一个新的“数组”作为中介来处理，多出了一部分开销。</p><h3 id="2、使用for…in循环"><a href="#2、使用for…in循环" class="headerlink" title="2、使用for…in循环"></a>2、使用for…in循环</h3><p>在Objective-C 2.0 中增加了for …In 形式的快速遍历。此种遍历方式语法简洁，速度飞快。示例如下：</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (id obj in array) {    NSLog(@&quot;%@&quot;,obj);}//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};for (id obj in dictM) {    NSLog(@&quot;%@&quot;,dictM[obj]);}// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];for (id obj in set) {    NSLog(@&quot;%@&quot;,obj);}// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];for (id obj in [array2 reverseObjectEnumerator]) {    NSLog(@&quot;%@&quot;,obj);}</code></pre><p>优点：1）语法简洁；2）效率最高；</p><p>缺点：无法获得当前遍历操作所针对的下标。</p><h3 id="3、使用NSEnumerator遍历"><a href="#3、使用NSEnumerator遍历" class="headerlink" title="3、使用NSEnumerator遍历"></a>3、使用NSEnumerator遍历</h3><p>NSEnumerator的使用和基本的for循环类似，不过代码量要大一些。示例如下：</p><pre><code>// 数组NSArray *arrayM = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];NSEnumerator *arrayEnumerator = [arrayM objectEnumerator];NSString *obj;while ((obj = [arrayEnumerator nextObject]) != nil) {    NSLog(@&quot;%@&quot;,obj);}// 字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};NSEnumerator *dictEnumerator = [dictM keyEnumerator];NSString *key;while ((key = [dictEnumerator nextObject]) != nil) {    NSString *obj = dictM[key];    NSLog(@&quot;%@&quot;,obj);}// 集合（无序、不能重复 其他和Array一样）NSSet * setM = [[NSSet alloc] initWithObjects:@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,@&quot;four&quot;, nil];NSEnumerator *setEnumerator = [setM objectEnumerator];NSString *setObj;while ((setObj = [setEnumerator nextObject]) != nil) {    NSLog(@&quot;%@&quot;,setObj);}// 反向遍历（以数组为例子）NSArray *arrayM2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];NSEnumerator *arrayEnumerator2 = [arrayM2 reverseObjectEnumerator];NSString *obj2;while ((obj2 = [arrayEnumerator2 nextObject]) != nil) {    NSLog(@&quot;%@&quot;,obj2);}</code></pre><p>优点：对于不同的数据类型，遍历的语法相似；内部可以简单的通过reverseObjectEnumerator设置进行反向遍历。</p><p>缺点：代码量稍大。</p><h3 id="4、基于Block的遍历方式"><a href="#4、基于Block的遍历方式" class="headerlink" title="4、基于Block的遍历方式"></a>4、基于Block的遍历方式</h3><p>基于Block的方式来进行遍历是最新引入的方法。它提供了遍历数组|字典等类型数据的最佳实践。示例如下：</p><pre><code>// 数组NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSLog(@&quot;%lu--%@&quot;,(unsigned long)idx,obj);}];//  字典NSDictionary *dictM = @{@&quot;1&quot;:@&quot;one&quot;,@&quot;2&quot;:@&quot;two&quot;,@&quot;3&quot;:@&quot;three&quot;};[dictM enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {    NSLog(@&quot;%@:%@&quot;,key,obj);}];// 集合（无序、不能重复 其他和Array一样）NSSet *set = [NSSet setWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;, nil];[set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {    NSLog(@&quot;%@&quot;,obj);}];// 反向遍历（以数组为例子）NSArray *array2 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;];[array2 enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSLog(@&quot;%zd--%@&quot;,idx,obj);}];</code></pre><p>优点：1）遍历时可以直接从block中获得需要的所有信息，包括下标、值等。特别相对于字典而言，不需要做多余的编码即可同时获得key和value的值。</p><p>　　　2）能够直接修改block中key或者obj的类型为真实类型，可以省去类型转换的工作。</p><p>　　　3）可以通过NSEnumerationConcurrent枚举值开启并发迭代功能。</p><p>说明：基于Block的遍历方式在实现反向遍历的时候也非常简单，使用enumerateObjectsWithOptions方法，传递NSEnumerationReverse作为参数即可，在处理遍历操作的时候推荐基于Block的遍历方式。</p><h3 id="5、使GCD中的dispatch-apply函数"><a href="#5、使GCD中的dispatch-apply函数" class="headerlink" title="5、使GCD中的dispatch_apply函数"></a>5、使GCD中的dispatch_apply函数</h3><p>使用GCD中的dispatch_apply函数也能实现字典、数组等的遍历，该函数比较适合处理耗时较长、迭代次数较多的情况。示例如下：</p><pre><code>NSArray *array3 = @[@&quot;10&quot;,@&quot;11&quot;,@&quot;12&quot;,@&quot;13&quot;,@&quot;14&quot;];dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(array3.count, queue, ^(size_t index) {    NSLog(@&quot;%@--%@&quot;,array3[index],[NSThread currentThread]);});</code></pre><p>优点：开启多条线程并发处理遍历任务，执行效率高。</p><p>缺点：1）对于字典和集合的处理需借助数组；2）无法实现反向遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、使用for循环&quot;&gt;&lt;a href=&quot;#1、使用for循环&quot; class=&quot;headerlink&quot; title=&quot;1、使用for循环&quot;&gt;&lt;/a&gt;1、使用for循环&lt;/h3&gt;&lt;p&gt;要遍历字典、数组或者是集合，for循环是最简单也用的比较多的方法，示例如下：　&lt;/p
      
    
    </summary>
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/categories/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS开发技巧" scheme="https://www.wangqian.ltd/tags/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
